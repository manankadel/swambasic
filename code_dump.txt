

### .\.env.local ###

# Shopify Storefront API (Public)
NEXT_PUBLIC_SHOPIFY_STOREFRONT_ACCESS_TOKEN="pvt"
NEXT_PUBLIC_SHOPIFY_STORE_DOMAIN="pvt"

# Shopify Admin API (Private - DO NOT prefix with NEXT_PUBLIC_)
SHOPIFY_ADMIN_ACCESS_TOKEN="pvt"

# Site Access
SITE_ACCESS_PASSWORD="pvt"
SESSION_SECRET="pvt"

### .\.gitignore ###

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*
.env.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts


### .\README.md ###

This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.


### .\code_dump.txt ###



### .\dump_project.py ###

import os

EXCLUDE_DIRS = {
    "node_modules", ".next", ".git", "__pycache__", ".vscode", ".idea", ".turbo", ".vercel", ".expo"
}

EXCLUDE_FILES = {
    ".DS_Store", "package-lock.json", "yarn.lock", "pnpm-lock.yaml", "bun.lockb"
}

EXCLUDE_EXTENSIONS = {
    ".lock", ".png", ".jpg", ".jpeg", ".gif", ".svg", ".ico", ".mp4", ".mp3",
    ".webm", ".ttf", ".woff", ".woff2", ".eot", ".otf", ".zip", ".tar", ".gz",
    ".exe", ".dll", ".bin", ".log"
}

structure_file = open("project_structure.txt", "w", encoding="utf-8")
code_dump_file = open("code_dump.txt", "w", encoding="utf-8")

def is_binary_or_excluded(filename):
    return (
        filename in EXCLUDE_FILES or
        any(filename.lower().endswith(ext) for ext in EXCLUDE_EXTENSIONS)
    )

def dump_structure_and_code(path, indent=""):
    for item in sorted(os.listdir(path)):
        full_path = os.path.join(path, item)

        if item in EXCLUDE_FILES:
            continue
        if os.path.isdir(full_path):
            if item in EXCLUDE_DIRS:
                continue
            structure_file.write(f"{indent}{item}/\n")
            dump_structure_and_code(full_path, indent + "  ")
        else:
            if is_binary_or_excluded(item):
                continue
            structure_file.write(f"{indent}{item}\n")
            try:
                with open(full_path, "r", encoding="utf-8") as f:
                    code_dump_file.write(f"\n\n### {full_path} ###\n\n")
                    code_dump_file.write(f.read())
            except Exception as e:
                code_dump_file.write(f"\n\n### {full_path} ###\n\n")
                code_dump_file.write(f"[Error reading file: {e}]\n")

if __name__ == "__main__":
    root_dir = "."  # Set to your project path if not in root
    dump_structure_and_code(root_dir)
    structure_file.close()
    code_dump_file.close()
    print("âœ… Done. Files saved: 'project_structure.txt' and 'code_dump.txt'")


### .\eslint.config.mjs ###

import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;


### .\next-env.d.ts ###

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.


### .\next.config.mjs ###

/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,

  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'cdn.shopify.com',
        port: '',
        pathname: '/**',
      },
    ],
  },

  async headers() {
    return [
      {
        source: '/:all*(svg|jpg|jpeg|png|gif|webp|mp4|webm|mp3|wav|ogg|woff2|woff|ttf)',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, max-age=31536000, immutable',
          },
        ],
      },
    ];
  },
};

export default nextConfig;


### .\package.json ###

{
  "name": "swambasic",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@react-three/drei": "^9.107.0",
    "@react-three/fiber": "^8.16.8",
    "@shopify/hydrogen-react": "^2025.4.0",
    "@vercel/analytics": "^1.5.0",
    "date-fns": "^4.1.0",
    "framer-motion": "^11.2.12",
    "next": "14.2.4",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "three": "^0.164.1"
  },
  "devDependencies": {
    "@types/node": "^20",
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@types/three": "^0.164.0",
    "autoprefixer": "^10.4.21",
    "eslint": "^8",
    "eslint-config-next": "14.2.4",
    "postcss": "^8",
    "tailwindcss": "^3.4.1",
    "typescript": "^5"
  }
}


### .\postcss.config.mjs ###

/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

export default config;

### .\project_structure.txt ###



### .\public\audio\typing.wav ###



### .\public\audio\typing.wav ###

[Error reading file: 'utf-8' codec can't decode byte 0x92 in position 4: invalid start byte]


### .\src\app\(main)\account\addresses\page.tsx ###

import Addresses from '@/components/modules/account/Addresses';
// We use the same logic to fetch the customer data
import { getCustomer } from '@/lib/shopify';
import { cookies } from 'next/headers';

// This page is now a Server Component
const AccountAddressesPage = async () => {
  const cookieStore = cookies();
  const customerAccessToken = cookieStore.get('swambasic_customer_token')?.value;

  if (!customerAccessToken) {
    return <Addresses addresses={[]} />;
  }
  
  const customer = await getCustomer(customerAccessToken);
  // We extract the addresses from the customer object
  const addresses = customer ? customer.addresses.edges.map(edge => edge.node) : [];

  return <Addresses addresses={addresses} />;
};

export default AccountAddressesPage;

### .\src\app\(main)\account\layout.tsx ###

"use client";
import Link from 'next/link';
import { usePathname, useRouter } from 'next/navigation';

const accountNavLinks = [
  { name: 'Order History', href: '/account/orders' },
  { name: 'Profile Details', href: '/account/profile' },
  { name: 'Addresses', href: '/account/addresses' },
];

export default function AccountLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const pathname = usePathname();
  const router = useRouter();

  // Logout ka function
  const handleLogout = async () => {
    try {
      // API call to delete the cookie
      await fetch('/api/auth/logout', { method: 'POST' });
      // Redirect to login page
      router.push('/login');
      router.refresh();
    } catch (error) {
      console.error('Failed to logout:', error);
    }
  };

  return (
    <main className="min-h-screen bg-black pt-40 pb-24 px-6 md:px-12">
      <div className="max-w-7xl mx-auto">
        <h1 className="font-display text-4xl md:text-5xl font-bold mb-8 md:mb-12">Personal Hub</h1>
        <div className="grid grid-cols-1 md:grid-cols-4 gap-12">
          <aside className="md:col-span-1">
            <nav className="flex flex-col gap-4">
              {accountNavLinks.map(link => {
                const isActive = pathname.includes(link.href);
                return (
                  <Link
                    key={link.name}
                    href={link.href}
                    className={`font-sans uppercase tracking-wider text-sm border-l-2 pl-4 transition-colors ${
                      isActive
                        ? 'text-white border-white'
                        : 'text-white/50 border-white/20 hover:text-white hover:border-white'
                    }`}
                  >
                    {link.name}
                  </Link>
                );
              })}
              {/* Yeh hai Logout button */}
              <button
                onClick={handleLogout}
                className="text-left font-sans uppercase tracking-wider text-sm border-l-2 pl-4 transition-colors text-white/50 border-white/20 hover:text-white hover:border-white"
              >
                Logout
              </button>
            </nav>
          </aside>
          <section className="md:col-span-3">
            {children}
          </section>
        </div>
      </div>
    </main>
  );
}

### .\src\app\(main)\account\login\page.tsx ###

import LoginRegister from '@/components/modules/account/LoginRegister';

const LoginPage = () => {
    // We will wrap this in a layout later that handles redirection if already logged in
    return (
        <main className="min-h-screen bg-black pt-40 pb-24 px-6 md:px-12">
            <LoginRegister />
        </main>
    );
};

export default LoginPage;

### .\src\app\(main)\account\orders\page.tsx ###

import OrderHistory from '@/components/modules/account/OrderHistory';
import { getCustomer } from '@/lib/shopify';
import { cookies } from 'next/headers';

// This is now a Server Component
const AccountOrdersPage = async () => {
  const cookieStore = cookies();
  const customerAccessToken = cookieStore.get('swambasic_customer_token')?.value;

  if (!customerAccessToken) {
    // Middleware should handle this, but as a fallback
    return <OrderHistory orders={[]} />;
  }

  const customer = await getCustomer(customerAccessToken);
  const orders = customer ? customer.orders.edges.map(edge => edge.node) : [];

  return <OrderHistory orders={orders} />;
};

export default AccountOrdersPage;

### .\src\app\(main)\account\page.tsx ###

import OrderHistory from '@/components/modules/account/OrderHistory';
// THE FIX: We import the exact same logic as the orders page
import { getCustomer } from '@/lib/shopify';
import { cookies } from 'next/headers';

// THE FIX: This page is now a Server Component and will fetch data
const AccountDashboardPage = async () => {
  const cookieStore = cookies();
  const customerAccessToken = cookieStore.get('swambasic_customer_token')?.value;

  // Agar token nahi hai, toh ek empty array bhej do
  if (!customerAccessToken) {
    return <OrderHistory orders={[]} />;
  }

  // Real-time data fetch karo
  const customer = await getCustomer(customerAccessToken);
  const orders = customer ? customer.orders.edges.map(edge => edge.node) : [];

  // Component ko asli data ke saath render karo
  return <OrderHistory orders={orders} />;
};

export default AccountDashboardPage;

### .\src\app\(main)\account\profile\page.tsx ###

import ProfileDetails from '@/components/modules/account/ProfileDetails';
// We use the same logic to fetch the customer data
import { getCustomer } from '@/lib/shopify';
import { cookies } from 'next/headers';

// This page is now a Server Component
const AccountProfilePage = async () => {
  const cookieStore = cookies();
  const customerAccessToken = cookieStore.get('swambasic_customer_token')?.value;

  if (!customerAccessToken) {
    // This is a fallback, middleware should prevent this.
    return <ProfileDetails customer={null} />;
  }

  // Fetch the full customer object
  const customer = await getCustomer(customerAccessToken);

  // Pass the entire customer object to the component
  return <ProfileDetails customer={customer} />;
};

export default AccountProfilePage;

### .\src\app\(main)\cart\page.tsx ###

// src/app/(main)/cart/page.tsx

"use client";
import Link from 'next/link';
import Image from 'next/image';
import { useCart, type Cart } from '@shopify/hydrogen-react';

type ArrayElement<T> = T extends readonly (infer U)[] ? U : T;
type CartLine = ArrayElement<Cart['lines']>;

// --- THIS IS THE FIX: The type for 'status' is now correct and matches the hook ---
type CartStatus = 'uninitialized' | 'fetching' | 'idle' | 'creating' | 'updating';

const CartLineItem = ({ 
    line,
    linesRemove,
    status 
}: { 
    line: CartLine,
    linesRemove: (lineIds: string[]) => void,
    status: CartStatus
}) => {
    return (
        <div className="flex gap-6 items-center">
            <div className="w-24 h-32 bg-white/5 rounded-md flex-shrink-0 overflow-hidden">
                {line?.merchandise?.image && (
                    <Image
                        src={line.merchandise.image.url ?? ""}
                        alt={line.merchandise.image.altText || line.merchandise.product?.title || ""}
                        width={96}
                        height={128}
                        className="w-full h-full object-cover"
                    />
                )}
            </div>
            <div className="flex-grow">
                <h3 className="font-sans font-semibold">{line?.merchandise?.product?.title ?? ""}</h3>
                <p className="font-sans text-sm text-white/50">
                    {line?.merchandise?.title}
                </p>
                <button 
                    // --- THIS IS THE FIX: We check if line.id exists before calling the function ---
                    onClick={() => {
                        if (line?.id) {
                            linesRemove([line.id]);
                        }
                    }}
                    disabled={status === 'updating'}
                    className="text-xs font-sans text-white/50 hover:text-red-400 transition-colors mt-2 disabled:opacity-50"
                >
                    Remove
                </button>
            </div>
            <div className="font-mono text-center">
                {line ? `x${line.quantity}` : null}
            </div>
            <div className="font-mono text-lg text-right">
                ${parseFloat(line?.cost?.totalAmount?.amount ?? "0").toFixed(2)}
            </div>
        </div>
    );
};


const CartPage = () => {
  const { lines, cost, checkoutUrl, status, linesRemove } = useCart();

  // --- THIS IS THE FIX: We now check for both loading states ---
  if (status === 'uninitialized' || status === 'fetching') {
      return (
          <main className="min-h-screen bg-black flex flex-col items-center justify-center text-center px-6">
              <h1 className="font-display text-5xl font-bold">Loading Cart...</h1>
          </main>
      );
  }

  if (!lines || lines.length === 0 || !cost) {
    return (
      <main className="min-h-screen bg-black flex flex-col items-center justify-center text-center px-6">
        <h1 className="font-display text-5xl font-bold">The Canvas Is Blank.</h1>
        <Link href="/catalog">
          <button className="mt-8 px-8 py-4 bg-white text-black font-sans font-bold uppercase tracking-widest rounded-full">
            Discover The Collection
          </button>
        </Link>
      </main>
    );
  }

  return (
    <main className="min-h-screen bg-black pt-40 pb-24 px-6 md:px-12">
      <div className="max-w-7xl mx-auto">
        <h1 className="font-display text-5xl font-bold mb-12">Your Cart</h1>
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 lg:gap-12">
          <div className="lg:col-span-2 flex flex-col gap-6">
            {lines.map(line => (
              line ? <CartLineItem key={line.id} line={line} linesRemove={linesRemove} status={status} /> : null
            ))}
          </div>
          <div className="lg:col-span-1">
             <div className="lg:sticky top-40 p-6 rounded-xl border border-white/10 bg-black/20 backdrop-blur-sm">
              <h2 className="font-display text-2xl font-bold">Summary</h2>
              <div className="mt-6 space-y-2 font-mono text-sm text-white/80">
                <div className="flex justify-between">
                  <span>Subtotal</span>
                  <span>${parseFloat(cost.subtotalAmount?.amount ?? "0").toFixed(2)}</span>
                </div>
                <div className="flex justify-between">
                  <span>Shipping</span>
                  <span className="text-xs">Calculated at next step</span>
                </div>
              </div>
              <div className="mt-6 border-t border-white/10 pt-4 flex justify-between font-mono font-bold">
                <span>Total</span>
                <span>${parseFloat(cost.totalAmount?.amount ?? "0").toFixed(2)}</span>
              </div>
              <a href={checkoutUrl} target="_blank" rel="noopener noreferrer" className="block text-center mt-6 w-full py-4 bg-white text-black font-sans font-bold uppercase tracking-widest rounded-full">
                Proceed to Checkout
              </a>
            </div>
          </div>
        </div>
      </div>
    </main>
  );
};

export default CartPage;

### .\src\app\(main)\catalog\page.tsx ###

// src/app/(main)/catalog/page.tsx

import { getProductsDetailed } from '@/lib/shopify'; // <-- Use the detailed function
import { CatalogClientWrapper } from '@/components/modules/catalog/CatalogClientWrapper';
import { ShopifyProductDetailed } from '@/types/shopify';

export const dynamic = 'force-dynamic';

export default async function CatalogPage() {
  
  // This now fetches the DETAILED products that the wrapper needs.
  const products: ShopifyProductDetailed[] = await getProductsDetailed(10); 

  return (
    <main className="relative min-h-screen w-full">
        <CatalogClientWrapper products={products} />
    </main>
  );
}

### .\src\app\(main)\home\page.tsx ###

// src/app/(main)/home/page.tsx

"use client";

import { HeroSection } from "@/components/modules/homepage/HeroSection";
import { FeaturedProducts } from "@/components/modules/homepage/FeaturedProducts";
import { motion } from "framer-motion";
import { BrandManifesto } from "@/components/modules/homepage/BrandManifesto";
import GlitchMarquee  from "@/components/modules/homepage/GlitchMarquee"; // <-- Import the new, correct component

const HomePage = () => {
  return (
    <main>
        <HeroSection />

      <motion.div
        initial={{ opacity: 0 }}
        whileInView={{ opacity: 1 }}
        viewport={{ once: true, amount: 0.2 }}
        transition={{ duration: 0.8 }}
      >
        <FeaturedProducts />
      </motion.div>
      
      <BrandManifesto />
      
      {/* --- THIS IS THE FIX: The new interactive art piece is here --- */}
      <GlitchMarquee />
      
    </main>
  );
};

export default HomePage;


### .\src\app\(main)\layout.tsx ###

// src/app/(main)/layout.tsx
"use client";
import { Header } from "@/components/core/Header";
import { Footer } from "@/components/core/Footer";
import { CartProvider, ShopifyProvider } from '@shopify/hydrogen-react';
import { CartToast } from '@/hooks/useCartNotification'; // Import the new toast component

export default function MainLayout({ children }: { children: React.ReactNode; }) {
  return (
    <ShopifyProvider
      storeDomain={process.env.NEXT_PUBLIC_SHOPIFY_STORE_DOMAIN!}
      storefrontToken={process.env.NEXT_PUBLIC_SHOPIFY_STOREFRONT_ACCESS_TOKEN!}
      storefrontApiVersion="2024-07"
      countryIsoCode="US"
      languageIsoCode="EN"
    >
      <CartProvider>
        <div>
          <Header />
          {children}
          <Footer />
          <CartToast /> {/* Add the global toast component here */}
        </div>
      </CartProvider>
    </ShopifyProvider>
  );
}

### .\src\app\(main)\login\page.tsx ###

// src/app/(main)/login/page.tsx
"use client";
import { useState } from 'react';
import { AuthForm } from '@/components/modules/auth/AuthForm';
import { FloatingParticlesBackground } from '@/components/core/FloatingParticlesBackground';
import { MotionPermissionPrompt } from '@/components/core/MotionPermissionPrompt';
import { useGyroscope } from '@/hooks/useGyroscope'; // <-- Use our new hook here too

const LoginPage = () => {
    const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
    // Get the smoothed gyro data from our hook
    const { smoothedGyroData } = useGyroscope();

    const handleMouseMove = (event: React.MouseEvent<HTMLDivElement>) => {
        const { clientWidth, clientHeight } = event.currentTarget;
        const x = (event.clientX / clientWidth) * 2 - 1;
        const y = -((event.clientY / clientHeight) * 2 - 1);
        setMousePosition({ x, y });
    };

    return (
        <div 
            className="min-h-screen bg-black flex items-end justify-center overflow-hidden relative p-4 pb-20"
            onMouseMove={handleMouseMove}
        >
            {/* We now pass the SMOOTHED gyro data down to the particles */}
            <FloatingParticlesBackground 
                mousePosition={mousePosition} 
                gyroData={smoothedGyroData} 
            />
            
            <MotionPermissionPrompt />
            
            <main className="w-full z-20">
                <AuthForm />
            </main>
        </div>
    );
};

export default LoginPage;

### .\src\app\(main)\privacy\page.tsx ###

// src/app/(main)/privacy/page.tsx
import { PolicyPageLayout } from '@/components/core/PolicyPageLayout';
export default function PrivacyPage() {
  return (
    <PolicyPageLayout title="Privacy Policy">
      <p>Your privacy is important to us. This policy outlines how we collect, use, and protect your personal information.</p>
      <h2>Information We Collect</h2>
      <p>We collect information you provide directly to us, such as your name, email address, shipping address, and payment information when you place an order.</p>
      <h2>How We Use Information</h2>
      <p>We use the information we collect to process transactions, send promotional emails (if you opt-in), and improve our services.</p>
    </PolicyPageLayout>
  );
}

### .\src\app\(main)\products\[handle]\page.tsx ###

// src/app/(main)/products/[handle]/page.tsx
"use client";

import { useState, useMemo, useEffect } from 'react';
import { notFound, useRouter } from 'next/navigation';
import { motion, AnimatePresence } from 'framer-motion';
import { useCart } from '@shopify/hydrogen-react';
import { ShopifyProductDetailed } from '@/types/shopify';
import { getProductByHandle } from '@/lib/shopify';
import Image from 'next/image';
import { useCartNotification } from '@/hooks/useCartNotification';
import { FullScreenImageViewer } from '@/components/core/FullScreenImageViewer';

const getOptimizedShopifyImageUrl = (url: string, size: number) => { if (!url) return ''; try { const urlObj = new URL(url); const extension = urlObj.pathname.split('.').pop(); const pathWithoutExtension = urlObj.pathname.substring(0, urlObj.pathname.lastIndexOf('.')); return `${urlObj.origin}${pathWithoutExtension}_${size}x.${extension}`; } catch (e) { return url; } };
const ExpandIcon = () => ( <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7"/></svg> );

const ProductDetailsClient = ({ product }: { product: ShopifyProductDetailed }) => {
    const { linesAdd, status: cartStatus } = useCart();
    const { showNotification } = useCartNotification();
    const [currentImageIndex, setCurrentImageIndex] = useState(0);
    const [selectedVariantId, setSelectedVariantId] = useState(product.variants.edges.find(v => v.node.availableForSale)?.node.id || product.variants.edges[0]?.node.id);
    const [fullScreenImage, setFullScreenImage] = useState<string | null>(null);

    const imageGallery = useMemo(() => { if (!product?.featuredImage) return []; const otherImages = product.images?.edges.map(edge => edge.node) || []; return [product.featuredImage, ...otherImages.filter(img => img.url !== product.featuredImage.url)]; }, [product]);
    const selectedVariant = useMemo(() => product.variants.edges.find(edge => edge.node.id === selectedVariantId)?.node, [product, selectedVariantId]);
    const isAddingToCart = cartStatus === 'updating';

    const handleAddToCart = () => { if (selectedVariant) { linesAdd([{ merchandiseId: selectedVariant.id, quantity: 1 }]); showNotification(`${product.title} added to cart`); } };

    return (
        <>
            <FullScreenImageViewer imageUrl={fullScreenImage} onClose={() => setFullScreenImage(null)} />
            <div className="grid grid-cols-1 md:grid-cols-2 gap-12 lg:gap-16">
                <div className="w-full flex flex-col gap-4">
                    <div className="relative w-full aspect-square">
                        <AnimatePresence mode="wait">
                            <motion.div key={currentImageIndex} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} transition={{ duration: 0.3 }} className="w-full h-full">
                                {imageGallery[currentImageIndex] && (
                                    <Image
                                        src={getOptimizedShopifyImageUrl(imageGallery[currentImageIndex].url, 800)}
                                        alt={imageGallery[currentImageIndex].altText || product.title}
                                        fill
                                        className="object-contain rounded-lg"
                                        priority
                                    />
                                )}
                            </motion.div>
                        </AnimatePresence>
                        <button onClick={() => setFullScreenImage(imageGallery[currentImageIndex].url)} className="absolute top-3 right-3 p-2 rounded-full bg-black/30 backdrop-blur-sm text-white/70 hover:text-white"> <ExpandIcon /> </button>
                    </div>
                    <div className="flex justify-center items-center gap-3">
                        {imageGallery.map((image, index) => (
                            <button key={image.url} onClick={() => setCurrentImageIndex(index)} className={`w-16 h-20 rounded-md overflow-hidden border-2 transition-colors ${currentImageIndex === index ? 'border-white' : 'border-transparent hover:border-white/50'}`}>
                                <Image src={getOptimizedShopifyImageUrl(image.url, 100)} alt={`Thumbnail ${index + 1}`} width={64} height={80} className="object-cover w-full h-full" />
                            </button>
                        ))}
                    </div>
                </div>
                <div className="flex flex-col">
                    <h1 className="font-display text-4xl md:text-5xl font-bold">{product.title}</h1>
                    {selectedVariant && <div className="inline-block my-4"> <p className="font-mono text-xl text-white/90 bg-white/5 px-3 py-1 rounded-md">${selectedVariant.price.amount}</p> </div>}
                    <div className="font-sans text-white/70 space-y-4 prose prose-invert max-w-none" dangerouslySetInnerHTML={{ __html: product.descriptionHtml }} />
                    <div className="mt-8 pt-8 border-t border-white/10">
                        <h2 className="font-sans text-sm uppercase tracking-wider text-white/50"> Size </h2>
                        <div className="flex flex-wrap gap-3 mt-4">
                            {product.variants?.edges.map(({ node: variant }) => ( <button key={variant.id} onClick={() => setSelectedVariantId(variant.id)} disabled={!variant.availableForSale} className={`px-4 py-2 rounded-md font-sans text-sm font-semibold border transition-colors duration-200 ${selectedVariantId === variant.id ? 'bg-white text-black border-white' : 'bg-transparent text-white border-white/20'} ${!variant.availableForSale ? 'opacity-30 cursor-not-allowed line-through' : 'hover:border-white/70'}`}> {variant.title} </button> ))}
                        </div>
                        <button onClick={handleAddToCart} disabled={!selectedVariant?.availableForSale || isAddingToCart} className="w-full mt-8 py-4 bg-white text-black font-sans font-bold uppercase tracking-widest disabled:opacity-50 enabled:hover:bg-white/80 transition-all rounded-full">
                            {isAddingToCart ? 'Adding...' : !selectedVariant?.availableForSale ? 'Sold Out' : 'Add to Cart'}
                        </button>
                    </div>
                </div>
            </div>
        </>
    );
};

// This is the server component that fetches the data
export default function ProductPage({ params }: { params: { handle: string } }) {
    const [product, setProduct] = useState<ShopifyProductDetailed | null>(null);

    useEffect(() => {
        const fetchProduct = async () => {
            const fetchedProduct = await getProductByHandle(params.handle);
            if (!fetchedProduct) {
                notFound();
            }
            setProduct(fetchedProduct);
        };
        fetchProduct();
    }, [params.handle]);

    if (!product) {
        return <div className="min-h-screen bg-black flex items-center justify-center text-white">Loading...</div>;
    }

    return (
        <main className="min-h-screen bg-black pt-40 pb-24 px-6 md:px-12">
            <div className="max-w-7xl mx-auto">
                <ProductDetailsClient product={product} />
            </div>
        </main>
    );
}

### .\src\app\(main)\reach-out\page.tsx ###

// src/app/(main)/reach-out/page.tsx
"use client";

import { motion, useMotionValue, useTransform } from 'framer-motion';
import { useState } from 'react';
import { FloatingParticlesBackground } from '@/components/core/FloatingParticlesBackground';

const containerVariants = { hidden: { opacity: 0 }, visible: { opacity: 1, transition: { staggerChildren: 0.1, delayChildren: 0.3 } } };
const itemVariants = { hidden: { y: 20, opacity: 0 }, visible: { y: 0, opacity: 1, transition: { duration: 0.8, ease: 'easeOut' } } };

export default function ReachOutPage() {
  const mouseX = useMotionValue(0);
  const mouseY = useMotionValue(0);
  const rotateX = useTransform(mouseY, [-0.5, 0.5], ['7deg', '-7deg']);
  const rotateY = useTransform(mouseX, [-0.5, 0.5], ['-7deg', '7deg']);
  
  const handleMouseMove = (event: React.MouseEvent<HTMLDivElement>) => {
    const { clientWidth, clientHeight } = event.currentTarget;
    const x = (event.clientX / clientWidth) - 0.5;
    const y = (event.clientY / clientHeight) - 0.5;
    mouseX.set(x);
    mouseY.set(y);
  };
  
  // --- THIS IS THE FIX: State management for the form ---
  const [formData, setFormData] = useState({ name: '', email: '', message: '' });
  const [formStatus, setFormStatus] = useState<'idle' | 'loading' | 'success' | 'error'>('idle');
  const [statusMessage, setStatusMessage] = useState('');

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
      setFormData({ ...formData, [e.target.name]: e.target.value });
  };

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
      e.preventDefault();
      setFormStatus('loading');
      setStatusMessage('');

      try {
          const response = await fetch('/api/contact', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(formData),
          });
          const result = await response.json();
          if (!response.ok) throw new Error(result.error || 'Something went wrong.');
          
          setFormStatus('success');
          setStatusMessage(result.message);
          setFormData({ name: '', email: '', message: '' }); // Clear form
      } catch (error: any) {
          setFormStatus('error');
          setStatusMessage(error.message);
      }
  };
  // --- END OF FIX ---

  return (
    <main className="relative min-h-screen w-full flex items-center justify-center overflow-hidden p-4 pt-32 pb-12" onMouseMove={handleMouseMove}>
      <FloatingParticlesBackground mousePosition={{ x: 0, y: 0 }} gyroData={{ x: 0, y: 0 }} />
      
      <motion.div className="w-full max-w-xl z-10" style={{ rotateX, rotateY, transformStyle: 'preserve-3d' }} variants={containerVariants} initial="hidden" animate="visible">
        <div className="rounded-2xl border border-white/10 bg-black/20 backdrop-blur-2xl shadow-2xl shadow-black/50 p-8 md:p-12">
            <motion.h1 variants={itemVariants} className="font-display text-4xl md:text-5xl font-bold mb-2"> Let's Connect </motion.h1>
            <motion.p variants={itemVariants} className="font-sans text-base text-white/60 mb-8 max-w-md"> For inquiries, collaborations, or conversations. </motion.p>
            
            {/* --- THIS IS THE FIX: Form now uses the new logic --- */}
            <motion.form variants={itemVariants} className="space-y-6" onSubmit={handleSubmit}>
                <div className="flex flex-col">
                  <label htmlFor="name" className="font-sans text-xs uppercase tracking-widest text-white/50 mb-2">Name</label>
                  <input type="text" id="name" name="name" value={formData.name} onChange={handleInputChange} required className="bg-black/20 border border-white/10 rounded-lg p-3 font-sans focus:outline-none focus:border-white/50 transition-colors" />
                </div>
                <div className="flex flex-col">
                  <label htmlFor="email" className="font-sans text-xs uppercase tracking-widest text-white/50 mb-2">Email</label>
                  <input type="email" id="email" name="email" value={formData.email} onChange={handleInputChange} required className="bg-black/20 border border-white/10 rounded-lg p-3 font-sans focus:outline-none focus:border-white/50 transition-colors" />
                </div>
                <div className="flex flex-col">
                  <label htmlFor="message" className="font-sans text-xs uppercase tracking-widest text-white/50 mb-2">Message</label>
                  <textarea id="message" name="message" value={formData.message} onChange={handleInputChange} required rows={4} className="bg-black/20 border border-white/10 rounded-lg p-3 font-sans focus:outline-none focus:border-white/50 transition-colors resize-none"></textarea>
                </div>
                <div>
                  <button type="submit" disabled={formStatus === 'loading'} className="w-full mt-2 py-3 bg-white text-black font-sans font-bold uppercase tracking-widest rounded-full hover:bg-white/80 active:scale-95 transition-all disabled:opacity-50">
                    {formStatus === 'loading' ? 'Sending...' : 'Send'}
                  </button>
                </div>
            </motion.form>
             {statusMessage && (
                <p className={`mt-4 text-center text-sm ${formStatus === 'error' ? 'text-red-400' : 'text-green-400'}`}>
                    {statusMessage}
                </p>
            )}
        </div>
        <motion.div variants={itemVariants} className="flex justify-center gap-6 mt-8 text-center">
            <div> <h3 className="font-sans text-xs uppercase tracking-widest text-white/50">Inquiries</h3> <a href="mailto:contact@swambasic.com" className="font-sans text-sm text-white hover:underline">contact@swambasic.com</a> </div>
            <div> <h3 className="font-sans text-xs uppercase tracking-widest text-white/50">Support</h3> <a href="mailto:support@swambasic.com" className="font-sans text-sm text-white hover:underline">support@swambasic.com</a> </div>
        </motion.div>
      </motion.div>
    </main>
  );
}

### .\src\app\(main)\refunds\page.tsx ###

// src/app/(main)/refunds/page.tsx
import { PolicyPageLayout } from '@/components/core/PolicyPageLayout';
export default function RefundsPage() {
  return (
    <PolicyPageLayout title="Cancellations & Refunds">
      <h2>Cancellations</h2>
      <p>You may request a cancellation within 24 hours of purchase, provided your order has not yet been shipped. Please contact us immediately at [support@swambasic.com].</p>
      <h2>Returns & Refunds</h2>
      <p>We accept returns on unworn, unwashed items with original tags attached within 14 days of delivery. To initiate a return, please contact our support team. Once we receive and inspect the item, a refund will be processed to your original payment method.</p>
      <p>Please note that shipping fees are non-refundable.</p>
    </PolicyPageLayout>
  );
}

### .\src\app\(main)\shipping\page.tsx ###

// src/app/(main)/shipping/page.tsx
import { PolicyPageLayout } from '@/components/core/PolicyPageLayout';
export default function ShippingPage() {
  return (
    <PolicyPageLayout title="Shipping Policy">
      <h2>Processing Time</h2>
      <p>Orders are processed within 1-3 business days. During peak seasons, processing times may be extended.</p>
      <h2>Domestic & International Shipping</h2>
      <p>We offer standard and expedited shipping options for both domestic and international orders. Shipping rates are calculated at checkout based on your location and selected service.</p>
      <h2>Tracking</h2>
      <p>Once your order has shipped, you will receive an email notification with a tracking number.</p>
    </PolicyPageLayout>
  );
}

### .\src\app\(main)\terms\page.tsx ###

// src/app/(main)/terms/page.tsx
import { PolicyPageLayout } from '@/components/core/PolicyPageLayout';
export default function TermsPage() {
  return (
    <PolicyPageLayout title="Terms & Conditions">
      <p>Welcome to SWAMBASIC. By accessing our website and purchasing our products, you agree to be bound by these terms and conditions. Please read them carefully.</p>
      <h2>Intellectual Property</h2>
      <p>All content on this site, including text, graphics, logos, and images, is the property of SWAMBASIC and is protected by international copyright laws.</p>
      <h2>Product Use</h2>
      <p>Our products are intended for personal, non-commercial use. Resale of our products is strictly prohibited without prior written consent.</p>
    </PolicyPageLayout>
  );
}

### .\src\app\api\access\route.ts ###

import { NextResponse } from 'next/server';
import { cookies } from 'next/headers';

const SESSION_TOKEN_NAME = 'swambasic_session';

// Generate a secure session token
function generateSessionToken(sessionSecret: string): string {
  const timestamp = Date.now().toString();
  const randomToken = Math.random().toString(36).substring(2) + 
                     Math.random().toString(36).substring(2) + 
                     Math.random().toString(36).substring(2);
  
  // Combine timestamp, token, and secret, then base64 encode
  const sessionData = `${timestamp}|${randomToken}|${sessionSecret}`;
  return btoa(sessionData);
}

export async function POST(request: Request) {
  try {
    const { password } = await request.json();

    if (!password) {
      return NextResponse.json({ error: 'Password is required' }, { status: 400 });
    }

    const sitePassword = process.env.SITE_ACCESS_PASSWORD;
    const sessionSecret = process.env.SESSION_SECRET;

    if (!sitePassword || !sessionSecret) {
      console.error("Missing environment variables for site access.");
      return NextResponse.json({ error: 'Server configuration error.' }, { status: 500 });
    }
    
    // Check if the password is correct
    if (password === sitePassword) {
      // Generate secure session token
      const sessionToken = generateSessionToken(sessionSecret);
      
      // Set secure cookie
      const cookieStore = cookies();
      cookieStore.set(SESSION_TOKEN_NAME, sessionToken, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        path: '/',
        sameSite: 'strict',
        maxAge: 60 * 60 * 24, // 24 hours (reduced from 7 days for security)
      });
      
      return NextResponse.json({ success: true }, { status: 200 });

    } else {
      // Incorrect password
      return NextResponse.json({ error: 'Invalid access code' }, { status: 401 });
    }

  } catch (error) {
    console.error('Access API error:', error);
    return NextResponse.json({ error: 'An unexpected error occurred.' }, { status: 500 });
  }
}

### .\src\app\api\account\addAddress\route.ts ###

// src/app/api/account/addAddress/route.ts

import { NextResponse } from 'next/server';
import { cookies } from 'next/headers';
import { createCustomerAddress } from '@/lib/shopify';
import { NewAddressInput } from '@/types/shopify'; // Import the type

export async function POST(request: Request) {
    const cookieStore = cookies();
    const token = cookieStore.get('swambasic_customer_token')?.value;

    // 1. Check if user is authenticated
    if (!token) {
        // Return a proper JSON error
        return NextResponse.json({ error: 'Not authenticated. Please log in.' }, { status: 401 });
    }

    try {
        // 2. Get the address data from the request
        const addressData: NewAddressInput = await request.json();

        // Optional: Add server-side validation here if needed
        if (!addressData.address1 || !addressData.city || !addressData.country || !addressData.zip || !addressData.province) {
            return NextResponse.json({ error: 'Missing required address fields.' }, { status: 400 });
        }

        // 3. Call the Shopify function to create the address
        const result = await createCustomerAddress(token, addressData);

        // 4. Check for errors from Shopify and return them as JSON
        if (result.customerUserErrors && result.customerUserErrors.length > 0) {
            return NextResponse.json({ error: result.customerUserErrors[0].message }, { status: 400 });
        }

        // 5. If successful, return a success response
        return NextResponse.json({ success: true, address: result.customerAddress }, { status: 200 });

    } catch (error) {
        // Handle unexpected errors
        console.error('Add Address API Error:', error);
        return NextResponse.json({ error: 'An unexpected error occurred.' }, { status: 500 });
    }
}

### .\src\app\api\account\updateProfile\route.ts ###

import { NextResponse } from 'next/server';
import { cookies } from 'next/headers';
import { updateCustomer } from '@/lib/shopify';

export async function POST(request: Request) {
    const cookieStore = cookies();
    const token = cookieStore.get('swambasic_customer_token')?.value;

    if (!token) {
        return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    try {
        const { firstName, lastName } = await request.json();

        if (!firstName || !lastName) {
            return NextResponse.json({ error: 'First and last name are required.' }, { status: 400 });
        }

        const result = await updateCustomer(token, { firstName, lastName });

        if (result.customerUserErrors && result.customerUserErrors.length > 0) {
            return NextResponse.json({ error: result.customerUserErrors[0].message }, { status: 400 });
        }

        return NextResponse.json({ success: true, customer: result.customer }, { status: 200 });

    } catch (error) {
        return NextResponse.json({ error: 'An unexpected error occurred.' }, { status: 500 });
    }
}

### .\src\app\api\auth\login\route.ts ###

import { NextResponse } from 'next/server';
import { cookies } from 'next/headers';
import { loginCustomer } from '@/lib/shopify';

const CUSTOMER_TOKEN_COOKIE_NAME = 'swambasic_customer_token';

export async function POST(request: Request) {
    try {
        const { email, password } = await request.json();

        if (!email || !password) {
            return NextResponse.json({ error: 'Email and password are required.' }, { status: 400 });
        }

        const loginResult = await loginCustomer({ email, password });

        // Handle Shopify errors (e.g., incorrect password)
        if (loginResult.customerUserErrors && loginResult.customerUserErrors.length > 0) {
            return NextResponse.json({ error: loginResult.customerUserErrors[0].message }, { status: 401 });
        }

        // Handle successful login
        if (loginResult.customerAccessToken) {
            const { accessToken, expiresAt } = loginResult.customerAccessToken;
            const cookieStore = cookies();
            
            cookieStore.set(CUSTOMER_TOKEN_COOKIE_NAME, accessToken, {
                httpOnly: true,
                secure: process.env.NODE_ENV === 'production',
                path: '/',
                sameSite: 'strict',
                expires: new Date(expiresAt),
            });
            
            return NextResponse.json({ success: true }, { status: 200 });
        }
        
        // Fallback error
        return NextResponse.json({ error: 'An unknown error occurred during login.' }, { status: 500 });

    } catch (error) {
        console.error('Login API error:', error);
        return NextResponse.json({ error: 'An unexpected error occurred.' }, { status: 500 });
    }
}

### .\src\app\api\auth\logout\route.ts ###

import { NextResponse } from 'next/server';
import { cookies } from 'next/headers';

const CUSTOMER_TOKEN_COOKIE_NAME = 'swambasic_customer_token';

export async function POST(request: Request) {
    try {
        const cookieStore = cookies();
        
        // Delete the cookie by setting its maxAge to 0
        cookieStore.set(CUSTOMER_TOKEN_COOKIE_NAME, '', {
            httpOnly: true,
            secure: process.env.NODE_ENV === 'production',
            path: '/',
            sameSite: 'strict',
            maxAge: 0, // This effectively deletes the cookie
        });

        return NextResponse.json({ success: true, message: 'Logged out successfully.' }, { status: 200 });

    } catch (error) {
        console.error('Logout API error:', error);
        return NextResponse.json({ error: 'An unexpected error occurred during logout.' }, { status: 500 });
    }
}

### .\src\app\api\auth\register\route.ts ###

// src/app/api/auth/register/route.ts

import { NextResponse } from 'next/server';
import { cookies } from 'next/headers';
import { loginCustomer } from '@/lib/shopify';

const CUSTOMER_TOKEN_COOKIE_NAME = 'swambasic_customer_token';

export async function POST(request: Request) {
    console.time("REGISTER_API_TOTAL_TIME"); // Start total timer

    try {
        const { firstName, lastName, email, password } = await request.json();

        if (!firstName || !lastName || !email || !password) {
            return NextResponse.json({ error: 'All fields are required.' }, { status: 400 });
        }

        const adminApiToken = process.env.SHOPIFY_ADMIN_ACCESS_TOKEN;
        const storeDomain = process.env.NEXT_PUBLIC_SHOPIFY_STORE_DOMAIN;
        const adminApiUrl = `https://${storeDomain}/admin/api/2024-07/customers.json`;

        const customerData = {
            customer: {
                first_name: firstName,
                last_name: lastName,
                email: email,
                password: password,
                password_confirmation: password,
                verified_email: true,
            }
        };

        // 1. Create the customer using the Admin API
        console.time("SHOPIFY_ADMIN_CREATE_CALL");
        const createResponse = await fetch(adminApiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-Shopify-Access-Token': adminApiToken! },
            body: JSON.stringify(customerData),
        });
        console.timeEnd("SHOPIFY_ADMIN_CREATE_CALL"); // End Admin API timer

        const createData = await createResponse.json();

        if (!createResponse.ok) {
            const errorMessage = createData.errors ? Object.values(createData.errors).flat().join(', ') : 'Failed to create account.';
            return NextResponse.json({ error: errorMessage }, { status: 400 });
        }

        // 2. Automatically log them in
        console.time("SHOPIFY_STOREFRONT_LOGIN_CALL");
        const loginResult = await loginCustomer({ email, password });
        console.timeEnd("SHOPIFY_STOREFRONT_LOGIN_CALL"); // End Storefront API timer

        if (loginResult.customerAccessToken) {
            const { accessToken, expiresAt } = loginResult.customerAccessToken;
            cookies().set(CUSTOMER_TOKEN_COOKIE_NAME, accessToken, {
                httpOnly: true,
                secure: process.env.NODE_ENV === 'production',
                path: '/',
                sameSite: 'strict',
                expires: new Date(expiresAt),
            });
            
            console.timeEnd("REGISTER_API_TOTAL_TIME"); // End total timer
            return NextResponse.json({ success: true }, { status: 201 });
        }

        return NextResponse.json({ error: 'Account created, but failed to log in.' }, { status: 500 });

    } catch (error) {
        console.error('Register API error:', error);
        console.timeEnd("REGISTER_API_TOTAL_TIME"); // End total timer in case of error
        return NextResponse.json({ error: 'An unexpected error occurred.' }, { status: 500 });
    }
}

### .\src\app\api\contact\route.ts ###

// src/app/api/contact/route.ts

import { NextResponse } from 'next/server';

export async function POST(request: Request) {
  const { name, email, message } = await request.json();

  if (!name || !email || !message) {
    return NextResponse.json({ error: 'All fields are required.' }, { status: 400 });
  }

  const adminApiToken = process.env.SHOPIFY_ADMIN_ACCESS_TOKEN;
  const storeDomain = process.env.NEXT_PUBLIC_SHOPIFY_STORE_DOMAIN;
  
  const adminApiUrl = `https://${storeDomain}/admin/api/2024-07/customers.json`;

  // We create a customer with a specific note and tag to identify them as a contact inquiry.
  // They are not subscribed to marketing.
  const customerData = {
    customer: {
      first_name: name.split(' ')[0],
      last_name: name.split(' ').slice(1).join(' ') || name.split(' ')[0], // Handle single names
      email: email,
      verified_email: false,
      note: `Contact Form Submission:\n\n${message}`,
      tags: "contact-form-inquiry",
    }
  };

  try {
    const response = await fetch(adminApiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Shopify-Access-Token': adminApiToken!,
      },
      body: JSON.stringify(customerData),
    });

    if (!response.ok) {
        const errorData = await response.json();
        console.error('Shopify API Error:', errorData);
        return NextResponse.json({ error: 'Failed to submit message.' }, { status: 500 });
    }

    return NextResponse.json({ success: true, message: "Message received. We'll be in touch." }, { status: 201 });

  } catch (error) {
    console.error('Contact API Error:', error);
    return NextResponse.json({ error: 'An internal server error occurred.' }, { status: 500 });
  }
}

### .\src\app\api\waitlist\route.ts ###

import { NextResponse } from 'next/server';

export async function POST(request: Request) {
  const { email, phone } = await request.json();

  if (!email) {
    return NextResponse.json({ error: 'Email is required' }, { status: 400 });
  }

  const adminApiToken = process.env.SHOPIFY_ADMIN_ACCESS_TOKEN;
  const storeDomain = process.env.NEXT_PUBLIC_SHOPIFY_STORE_DOMAIN;
  
  // Use REST API instead of GraphQL
  const restApiUrl = `https://${storeDomain}/admin/api/2024-04/customers.json`;

  const customerData = {
    customer: {
      email: email,
      phone: phone,
      tags: "waitlist,pre-launch",
      verified_email: false,
      marketing_opt_in_level: null
    }
  };

  try {
    const response = await fetch(restApiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Shopify-Access-Token': adminApiToken!,
      },
      body: JSON.stringify(customerData),
    });

    const responseText = await response.text();
    console.log('Shopify REST API Response Status:', response.status);
    console.log('Shopify REST API Response:', responseText);

    // Parse the response
    let data;
    try {
        data = JSON.parse(responseText);
    } catch (e) {
        console.error("Failed to parse Shopify response as JSON:", responseText);
        return NextResponse.json({ error: 'Invalid response from Shopify.' }, { status: 500 });
    }

    // Success case (201 Created or 200 OK)
    if (response.status === 201 || response.status === 200) {
        const customer = data.customer;
        if (customer && customer.id) {
            console.log('Customer created successfully:', customer.id);
            return NextResponse.json({ 
                success: true, 
                message: "Successfully joined the waitlist!"
            }, { status: 200 });
        }
    }

    // Handle specific error cases
    if (response.status === 422 && data.errors) {
        // Validation errors
        console.error('Shopify validation errors:', data.errors);
        
        // Check for duplicate email
        if (data.errors.email && data.errors.email.includes('has already been taken')) {
            return NextResponse.json({ 
                success: true, 
                message: 'You are already on our waitlist!' 
            }, { status: 200 });
        }
        
        // Other validation errors
        const errorMessage = Object.values(data.errors)[0] as string;
        return NextResponse.json({ error: errorMessage }, { status: 400 });
    }

    // Other error cases
    if (response.status === 401) {
        return NextResponse.json({ error: 'Authentication failed. Check your access token.' }, { status: 500 });
    }

    if (response.status === 403) {
        return NextResponse.json({ error: 'Permission denied. Check your app permissions.' }, { status: 500 });
    }

    // General failure
    return NextResponse.json({ 
        error: `Failed to create customer: ${response.status}` 
    }, { status: 500 });

  } catch (error) {
    console.error('API Route Crashed:', error);
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}

### .\src\app\fonts.ts ###

import { Poppins, Unbounded } from 'next/font/google';
import localFont from 'next/font/local'; // <-- IMPORT THIS

export const fontPoppins = Poppins({
  subsets: ['latin'],
  weight: ['400', '600', '700'],
  variable: '--font-poppins',
});

export const fontUnbounded = Unbounded({
    subsets: ['latin'],
    weight: ['700', '900'],
    variable: '--font-unbounded',
});

// DEFINE THE NEW LOCAL FONT HERE
export const fontGenoa = localFont({
  src: '../assets/fonts/genoa.otf', // <-- PATH TO YOUR FONT FILE
  display: 'swap',
  variable: '--font-genoa', // <-- CSS variable we will use
});

### .\src\app\globals.css ###

@tailwind base;
@tailwind components;
@tailwind utilities;

html, body {
  padding: 0;
  margin: 0;
  overflow-x: hidden;
}

body {
  @apply bg-black text-foreground;
}

/* NEW: Shimmer/Glow animation for text */
.animate-shimmer-glow {
  background: linear-gradient(90deg, #ffffff 25%, #888888 50%, #ffffff 75%);
  background-size: 400% 100%;
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  animation: shimmer-glow 8s linear infinite;
}

@keyframes shimmer-glow {
  0% {
    background-position: 200% 0;
  }
  100% {
    background-position: -200% 0;
  }
}
/* ADD THIS CODE AT THE END OF THE FILE */

@keyframes liquid-gradient {
  0% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0% 50%;
  }
}

/* src/app/globals.css */

/* Add this at the end of the file */
@keyframes scroll-left {
  from {
    transform: translateX(0%);
  }
  to {
    transform: translateX(-50%);
  }
}

.animate-scroll-left {
  animation: scroll-left 40s linear infinite;
}
.text-stroke {
  -webkit-text-stroke: 1px rgba(255, 255, 255, 0.8);
  -webkit-text-fill-color: transparent;
}

/* Add this to your global CSS file (e.g., globals.css or app.css) */

/* Hide scrollbar while maintaining scroll functionality */
.hide-scrollbar {
  /* Webkit browsers (Chrome, Safari, Edge) */
  -webkit-overflow-scrolling: touch;
  scrollbar-width: none; /* Firefox */
  -ms-overflow-style: none; /* IE and Edge */
}

.hide-scrollbar::-webkit-scrollbar {
  display: none; /* Chrome, Safari, Opera */
}

/* Apply to html and body when content is revealed */
.catalog-revealed {
  scrollbar-width: none; /* Firefox */
  -ms-overflow-style: none; /* IE and Edge */
}

.catalog-revealed::-webkit-scrollbar {
  display: none; /* Chrome, Safari, Opera */
}

/* Utility class for hiding scrollbars */
.scrollbar-hide {
  /* IE and Edge */
  -ms-overflow-style: none;
  
  /* Firefox */
  scrollbar-width: none;
}

.scrollbar-hide::-webkit-scrollbar {
  /* WebKit */
  display: none;
}

### .\src\app\layout.tsx ###

import type { Metadata } from 'next'
import './globals.css'
import { fontPoppins, fontUnbounded, fontGenoa } from './fonts';
import { BackgroundMusicPlayer } from '@/components/core/BackgroundMusicPlayer';
import { GlobalSoundEffects } from '@/components/core/GlobalSoundEffects';
import { AppHeightProvider } from '@/components/core/AppHeightProvider'; // <-- IMPORT THE NEW PROVIDER
import { Analytics } from "@vercel/analytics/next"

export const metadata = {
  title: 'SWAMBASIC - Coming Soon',
  description: 'Luxury Streetwear. Join the waitlist.',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en" className={[
        fontPoppins.variable, 
        fontUnbounded.variable, 
        fontGenoa.variable, 
        'dark'
      ].join(' ')}>
      <body>
        <Analytics/>
        {/* WRAP everything in the AppHeightProvider */}
        <AppHeightProvider>
            <GlobalSoundEffects />
            {children}
            <BackgroundMusicPlayer />
        </AppHeightProvider>
      </body>
    </html>
  )
}

### .\src\app\page.tsx ###

"use client";

import { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useRouter } from 'next/navigation';
import { GatewayAnimation } from '@/components/modules/GatewayAnimation';
import { WaitlistForm } from '@/components/modules/WaitlistForm';
import CountdownTimer from '@/components/modules/CountdownTimer';
import { InteractiveLiquidBackground } from '@/components/core/InteractiveLiquidBackground';
import { useSound } from '@/hooks/useSound';

// ==================================================================
// PERFORMANCE CONSTANTS
// ==================================================================
const ANIMATION_CONFIG = {
  CONTENT_DELAY: 2500,
  MOTION_DURATION: 1.0,
  MOTION_EASE: 'easeInOut',
  FADE_DELAY: 0.5,
} as const;

const MOTION_VARIANTS = {
  content: {
    initial: { opacity: 0 },
    animate: { opacity: 1 },
    transition: { 
      duration: ANIMATION_CONFIG.MOTION_DURATION, 
      ease: ANIMATION_CONFIG.MOTION_EASE, 
      delay: ANIMATION_CONFIG.FADE_DELAY 
    }
  },
  layout: {
    transition: { 
      duration: ANIMATION_CONFIG.MOTION_DURATION, 
      ease: ANIMATION_CONFIG.MOTION_EASE 
    }
  }
} as const;

const STYLES = {
  main: {
    height: 'calc(var(--app-height, 100vh))',
    contain: 'layout style paint',
    willChange: 'auto'
  },
  input: {
    contain: 'layout style'
  },
  button: {
    contain: 'layout style',
    willChange: 'color, opacity'
  }
} as const;

// ==================================================================
// OPTIMIZED ARROW ICON COMPONENT
// ==================================================================
const ArrowIcon = () => (
  <svg 
    xmlns="http://www.w3.org/2000/svg" 
    width="24" 
    height="24" 
    viewBox="0 0 24 24" 
    fill="none" 
    stroke="currentColor" 
    strokeWidth="2" 
    strokeLinecap="round" 
    strokeLinejoin="round"
    style={{ pointerEvents: 'none' }}
  >
    <line x1="5" y1="12" x2="19" y2="12"></line>
    <polyline points="12 5 19 12 12 19"></polyline>
  </svg>
);

// ==================================================================
// OPTIMIZED PASSWORD ACCESS COMPONENT
// ==================================================================
const PasswordAccess = () => {
  const router = useRouter();
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const abortControllerRef = useRef<AbortController | null>(null);
  
  // Optimized sound hook with lazy loading
  const playHoverSound = useSound('/audio/hover.mp3', 0.3);

  // Memoized input change handler
  const handlePasswordChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setPassword(e.target.value);
    if (error) setError(''); // Clear error on new input
  }, [error]);

  // Optimized submit handler with abort controller
  const handleSubmit = useCallback(async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    
    if (!password.trim() || isLoading) return;
    
    // Cancel any pending request
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    
    setIsLoading(true);
    setError('');
    
    // Create new abort controller
    abortControllerRef.current = new AbortController();
    
    try {
      const response = await fetch('/api/access', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ password }),
        signal: abortControllerRef.current.signal,
      });

      if (response.ok) {
        // Use replace for better performance
        router.replace('/home');
      } else {
        const data = await response.json();
        setError(data.error || 'Invalid access code.');
      }
    } catch (err: any) {
      if (err.name !== 'AbortError') {
        setError('Connection error. Please try again.');
      }
    } finally {
      setIsLoading(false);
    }
  }, [password, isLoading, router]);

  // Optimized hover handler
  const handleMouseEnter = useCallback(() => {
    if (!isLoading) playHoverSound();
  }, [playHoverSound, isLoading]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, []);

  // Memoized form elements
  const formContent = useMemo(() => (
    <form onSubmit={handleSubmit} className="flex items-center gap-4">
      <input
        type="password"
        value={password}
        onChange={handlePasswordChange}
        placeholder="Enter Access Code"
        className="font-sans w-full max-w-[240px] bg-transparent border-b-2 border-foreground/50 focus:border-foreground text-center text-lg focus:outline-none transition-colors duration-300 disabled:opacity-50"
        disabled={isLoading}
        autoComplete="current-password"
        style={STYLES.input}
      />
      <button
        type="submit"
        disabled={isLoading || !password.trim()}
        className="text-foreground/80 hover:text-white transition-colors disabled:opacity-50"
        onMouseEnter={handleMouseEnter}
        style={STYLES.button}
        aria-label="Submit access code"
      >
        <ArrowIcon />
      </button>
    </form>
  ), [password, isLoading, handleSubmit, handlePasswordChange, handleMouseEnter]);

  return (
    <div className="mt-8 flex flex-col items-center">
      {formContent}
      {error && (
        <p className="mt-2 text-sm text-red-400" role="alert">
          {error}
        </p>
      )}
    </div>
  );
};

// ==================================================================
// OPTIMIZED MAIN GATEWAY PAGE COMPONENT
// ==================================================================
export default function GatewayPage() {
  const [showContent, setShowContent] = useState(false);
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Optimized content reveal effect
  useEffect(() => {
    timeoutRef.current = setTimeout(() => {
      setShowContent(true);
    }, ANIMATION_CONFIG.CONTENT_DELAY);

    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);

  // Memoized content section
  const contentSection = useMemo(() => (
    <AnimatePresence mode="wait">
      {showContent && (
        <motion.div
          className="flex w-full max-w-sm flex-col items-center text-center"
          {...MOTION_VARIANTS.content}
        >
          <p className="font-sans text-sm md:text-xl mt-3 mb-4 md:mt-6 md:mb-6 text-foreground/80 animate-shimmer-glow px-2">
            Join the waitlist for exclusive access.
          </p>
          
          <div className="mb-4 md:mb-6">
            <CountdownTimer />
          </div>
          
          <div className="w-full flex justify-center px-2">
            <WaitlistForm />
          </div>
          
          <div className="mt-4 md:mt-8 mb-4 md:mb-0">
            <PasswordAccess />
          </div>
        </motion.div>
      )}
    </AnimatePresence>
  ), [showContent]);

  return (
    <div className="min-h-screen">
      <InteractiveLiquidBackground />
      <main 
        style={STYLES.main}
        className="relative flex flex-col items-center justify-center px-4 py-8"
      >
        <div className="flex flex-col items-center justify-center w-full max-w-4xl mx-auto">
          <motion.div layout {...MOTION_VARIANTS.layout} className="mb-4 md:mb-8">
            <GatewayAnimation />
          </motion.div>
          {contentSection}
        </div>
      </main>
    </div>
  );
}

### .\src\components\core\AppHeightProvider.tsx ###

"use client";

import { useEffect } from 'react';

/**
 * This component solves the "dynamic viewport" problem on mobile browsers.
 * It measures the actual window.innerHeight and sets it as a CSS variable (`--app-height`).
 * This ensures our layout is always based on the REAL visible screen space.
 */
export const AppHeightProvider = ({ children }: { children: React.ReactNode }) => {
  useEffect(() => {
    const setAppHeight = () => {
      // Get the actual inner height of the window
      const appHeight = `${window.innerHeight}px`;
      // Set it as a CSS variable on the root HTML element
      document.documentElement.style.setProperty('--app-height', appHeight);
    };

    // Set the height when the component mounts
    setAppHeight();

    // Also set it whenever the window is resized
    window.addEventListener('resize', setAppHeight);

    // Clean up the event listener when the component unmounts
    return () => {
      window.removeEventListener('resize', setAppHeight);
    };
  }, []);

  return <>{children}</>;
};

### .\src\components\core\AtmosphericBackground.tsx ###

// src/components/core/AtmosphericBackground.tsx

"use client";

// THE FIX: The package is "@react-three/fiber", not "@react-three-fiber"
// I am also importing `RootState` for correct typing in useFrame.
import { Canvas, useFrame, extend, useLoader, RootState } from '@react-three/fiber';
import { useRef, useEffect } from 'react';
import * as THREE from 'three';
import { shaderMaterial } from '@react-three/drei';
import { ShopifyProduct } from '@/types/shopify';

const MAX_PRODUCTS = 10; 

const AtmosphericMaterial = shaderMaterial(
  { 
    u_time: 0,
    u_mouse: new THREE.Vector2(0.5, 0.5),
    u_textures: [], 
    u_positions: [],
    u_scales: [],
    u_focused_index: -1,
  },
  ` varying vec2 vUv;
    void main() { gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); vUv = uv; }`,
  ` varying vec2 vUv;
    uniform float u_time;
    uniform vec2 u_mouse;
    uniform sampler2D u_textures[${MAX_PRODUCTS}];
    uniform vec2 u_positions[${MAX_PRODUCTS}];
    uniform vec2 u_scales[${MAX_PRODUCTS}];
    uniform int u_focused_index;

    vec3 render_product(int index, vec3 current_color, sampler2D tex) {
        if (u_positions[index] == vec2(-10.0, -10.0)) return current_color;
        vec2 pos = u_positions[index];
        vec2 scale = u_scales[index];
        vec2 productUv = (vUv - pos) / scale + 0.5;

        if (productUv.x > 0.0 && productUv.x < 1.0 && productUv.y > 0.0 && productUv.y < 1.0) {
            vec4 texColor = texture2D(tex, productUv);
            float dist = distance(productUv, vec2(0.5));
            float alpha = smoothstep(0.5, 0.45, dist);
            float focus_mult = (index == u_focused_index) ? 1.0 : 0.3;
            return mix(current_color, texColor.rgb, texColor.a * alpha * focus_mult);
        }
        return current_color;
    }

    float random(vec2 p) { return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5453); }
    float noise(vec2 p) {
        vec2 i = floor(p); vec2 f = fract(p);
        vec2 u = f * f * (3.0 - 2.0 * f);
        return mix(mix(random(i), random(i + vec2(1.0, 0.0)), u.x),
                   mix(random(i + vec2(0.0, 1.0)), random(i + vec2(1.0, 1.0)), u.x), u.y);
    }
    
    void main() {
        vec2 p = vUv * 2.0 - u_mouse * 0.1;
        float value = noise(p + u_time * 0.03);
        vec3 color = vec3(smoothstep(0.4, 0.7, value)) * 0.1 + 0.05;

        color = render_product(0, color, u_textures[0]);
        color = render_product(1, color, u_textures[1]);
        color = render_product(2, color, u_textures[2]);
        color = render_product(3, color, u_textures[3]);
        color = render_product(4, color, u_textures[4]);
        color = render_product(5, color, u_textures[5]);
        color = render_product(6, color, u_textures[6]);
        color = render_product(7, color, u_textures[7]);
        color = render_product(8, color, u_textures[8]);
        color = render_product(9, color, u_textures[9]);
        
        gl_FragColor = vec4(color, 1.0);
    }`
);

extend({ AtmosphericMaterial });

const Scene = ({ products, focusedIndex }: { products: ShopifyProduct[], focusedIndex: number }) => {
    const materialRef = useRef<any>();
    
    const loadedTextures = useLoader(THREE.TextureLoader, products.map(p => p.featuredImage?.url || ''));

    useEffect(() => {
      if (!materialRef.current || !loadedTextures || loadedTextures.length === 0) return;

      const paddedTextures = new Array(MAX_PRODUCTS).fill(new THREE.Texture());
      const paddedPositions = new Array(MAX_PRODUCTS).fill(new THREE.Vector2(-10.0, -10.0));
      const paddedScales = new Array(MAX_PRODUCTS).fill(new THREE.Vector2(0, 0));

      products.forEach((_, i) => {
          if (loadedTextures[i]) {
              paddedTextures[i] = loadedTextures[i];
              paddedPositions[i] = new THREE.Vector2(0.15 + (i % 4) * 0.22, 0.2 + Math.floor(i / 4) * 0.3);
              paddedScales[i] = new THREE.Vector2(0.2, 0.3);
          }
      });

      materialRef.current.uniforms.u_textures.value = paddedTextures;
      materialRef.current.uniforms.u_positions.value = paddedPositions;
      materialRef.current.uniforms.u_scales.value = paddedScales;

    }, [loadedTextures, products]);

    // THE FIX: Added correct types for the useFrame callback parameters
    useFrame((state: RootState, delta: number) => {
        if (materialRef.current) {
            materialRef.current.uniforms.u_time.value += delta * 0.1;
            materialRef.current.uniforms.u_mouse.value.lerp(state.pointer, 0.05);
            materialRef.current.uniforms.u_focused_index.value = focusedIndex;
        }
    });

    return (
        <mesh>
            <planeGeometry args={[2, 2]} />
            {/* @ts-ignore */}
            <atmosphericMaterial ref={materialRef} key={AtmosphericMaterial.key} />
        </mesh>
    );
};

export const AtmosphericBackground = ({ products, focusedIndex }: { products: ShopifyProduct[], focusedIndex: number }) => {
    if (!products || products.length === 0) return null;
    return (
        <div className="absolute inset-0 bg-[#111] z-[-1]">
            <Canvas camera={{ position: [0, 0, 1] }}>
                <Scene products={products} focusedIndex={focusedIndex} />
            </Canvas>
        </div>
    );
};

### .\src\components\core\BackgroundMusicPlayer.tsx ###

"use client";

import { useState, useRef, useEffect, useCallback, useMemo } from 'react';

// ==================================================================
// OPTIMIZED ICON COMPONENTS
// ==================================================================
const SoundOnIcon = () => (
  <svg 
    width="24" 
    height="24" 
    viewBox="0 0 24 24" 
    fill="none" 
    stroke="currentColor" 
    strokeWidth="2" 
    strokeLinecap="round" 
    strokeLinejoin="round"
    style={{ pointerEvents: 'none' }}
  >
    <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
    <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
    <path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path>
  </svg>
);

const PlayIcon = () => (
  <svg 
    width="24" 
    height="24" 
    viewBox="0 0 24 24" 
    fill="none" 
    stroke="currentColor" 
    strokeWidth="2" 
    strokeLinecap="round" 
    strokeLinejoin="round"
    style={{ pointerEvents: 'none' }}
  >
    <polygon points="5 3 19 12 5 21 5 3"></polygon>
  </svg>
);

// ==================================================================
// PERFORMANCE CONSTANTS
// ==================================================================
const AUDIO_CONFIG = {
  START_TIME: 93,
  PRELOAD: 'auto',
  VOLUME: 0.7, // Slightly lower volume for better UX
  FADE_IN_DURATION: 1000, // 1 second fade in
};

const BUTTON_STYLES: React.CSSProperties = {
  position: 'fixed',
  bottom: '24px',
  right: '24px',
  zIndex: 50,
  padding: '12px',
  borderRadius: '50%',
  backgroundColor: 'rgba(0, 0, 0, 0.3)',
  backdropFilter: 'blur(8px)',
  border: 'none',
  cursor: 'pointer',
  transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
  willChange: 'transform, opacity',
  contain: 'layout style paint',
};

// ==================================================================
// OPTIMIZED BACKGROUND MUSIC PLAYER
// ==================================================================
export const BackgroundMusicPlayer = () => {
  const audioRef = useRef<HTMLAudioElement>(null);
  const fadeIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const userInteractedRef = useRef(false);
  const retryTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  
  const [isPlaying, setIsPlaying] = useState(false);
  const [isLoaded, setIsLoaded] = useState(false);
  const [hasError, setHasError] = useState(false);

  // ==================================================================
  // OPTIMIZED FADE IN FUNCTION
  // ==================================================================
  const fadeInAudio = useCallback((audio: HTMLAudioElement) => {
    audio.volume = 0;
    const steps = 20;
    const volumeStep = AUDIO_CONFIG.VOLUME / steps;
    const timeStep = AUDIO_CONFIG.FADE_IN_DURATION / steps;
    
    let currentStep = 0;
    
    if (fadeIntervalRef.current) {
      clearInterval(fadeIntervalRef.current);
    }
    
    fadeIntervalRef.current = setInterval(() => {
      currentStep++;
      audio.volume = Math.min(volumeStep * currentStep, AUDIO_CONFIG.VOLUME);
      
      if (currentStep >= steps) {
        if (fadeIntervalRef.current) {
          clearInterval(fadeIntervalRef.current);
          fadeIntervalRef.current = null;
        }
      }
    }, timeStep);
  }, []);

  // ==================================================================
  // OPTIMIZED AUTOPLAY FUNCTION
  // ==================================================================
  const attemptAutoplay = useCallback(async () => {
    const audio = audioRef.current;
    if (!audio || hasError) return;

    try {
      // Set start time
      audio.currentTime = AUDIO_CONFIG.START_TIME;
      
      // Multiple autoplay strategies for maximum compatibility
      const playPromise = audio.play();
      
      if (playPromise !== undefined) {
        await playPromise;
        setIsPlaying(true);
        fadeInAudio(audio);
      }
    } catch (error) {
      console.warn("Autoplay prevented:", error);
      setIsPlaying(false);
      
      // Retry autoplay on next user interaction
      const handleFirstInteraction = () => {
        if (!userInteractedRef.current) {
          userInteractedRef.current = true;
          attemptAutoplay();
          document.removeEventListener('click', handleFirstInteraction);
          document.removeEventListener('touchstart', handleFirstInteraction);
          document.removeEventListener('keydown', handleFirstInteraction);
        }
      };
      
      document.addEventListener('click', handleFirstInteraction, { passive: true });
      document.addEventListener('touchstart', handleFirstInteraction, { passive: true });
      document.addEventListener('keydown', handleFirstInteraction, { passive: true });
    }
  }, [fadeInAudio, hasError]);

  // ==================================================================
  // OPTIMIZED PLAY/PAUSE TOGGLE
  // ==================================================================
  const togglePlayPause = useCallback(async () => {
    const audio = audioRef.current;
    if (!audio || hasError) return;

    try {
      if (isPlaying) {
        audio.pause();
        setIsPlaying(false);
        if (fadeIntervalRef.current) {
          clearInterval(fadeIntervalRef.current);
          fadeIntervalRef.current = null;
        }
      } else {
        // Set start time if at beginning
        if (audio.currentTime < AUDIO_CONFIG.START_TIME) {
          audio.currentTime = AUDIO_CONFIG.START_TIME;
        }
        
        await audio.play();
        setIsPlaying(true);
        fadeInAudio(audio);
      }
      
      userInteractedRef.current = true;
    } catch (error) {
      console.error("Error toggling audio:", error);
      setHasError(true);
    }
  }, [isPlaying, fadeInAudio, hasError]);

  // ==================================================================
  // OPTIMIZED EFFECTS
  // ==================================================================
  useEffect(() => {
    const audio = audioRef.current;
    if (!audio) return;

    // Audio event handlers
    const handleCanPlayThrough = () => {
      setIsLoaded(true);
      if (!userInteractedRef.current) {
        // Small delay to ensure audio is fully ready
        retryTimeoutRef.current = setTimeout(attemptAutoplay, 100);
      }
    };

    const handleError = () => {
      console.error("Audio loading error");
      setHasError(true);
      setIsLoaded(false);
    };

    const handleEnded = () => {
      // Reset to start time when song ends (for looping)
      audio.currentTime = AUDIO_CONFIG.START_TIME;
    };

    const handlePlay = () => setIsPlaying(true);
    const handlePause = () => setIsPlaying(false);

    // Add event listeners
    audio.addEventListener('canplaythrough', handleCanPlayThrough);
    audio.addEventListener('error', handleError);
    audio.addEventListener('ended', handleEnded);
    audio.addEventListener('play', handlePlay);
    audio.addEventListener('pause', handlePause);

    // Preload audio
    audio.load();

    // Cleanup
    return () => {
      if (fadeIntervalRef.current) {
        clearInterval(fadeIntervalRef.current);
      }
      if (retryTimeoutRef.current) {
        clearTimeout(retryTimeoutRef.current);
      }
      
      audio.removeEventListener('canplaythrough', handleCanPlayThrough);
      audio.removeEventListener('error', handleError);
      audio.removeEventListener('ended', handleEnded);
      audio.removeEventListener('play', handlePlay);
      audio.removeEventListener('pause', handlePause);
    };
  }, [attemptAutoplay]);

  // ==================================================================
  // MEMOIZED COMPONENTS
  // ==================================================================
  const buttonIcon = useMemo(() => {
    if (hasError) return <PlayIcon />;
    return isPlaying ? <SoundOnIcon /> : <PlayIcon />;
  }, [isPlaying, hasError]);

  const buttonAriaLabel = useMemo(() => {
    if (hasError) return "Audio unavailable";
    return isPlaying ? "Pause music" : "Play music";
  }, [isPlaying, hasError]);

  // Don't render if audio failed to load
  if (hasError) {
    return null;
  }

  return (
    <>
      <audio 
        ref={audioRef}
        src="https://cdn.jsdelivr.net/gh/manankadel/swambasic@main/public/assets/audio/background-music.mp3
"
        loop
        preload={AUDIO_CONFIG.PRELOAD}
        style={{ display: 'none' }}
      />
      
      <button
        onClick={togglePlayPause}
        style={BUTTON_STYLES}
        className="text-white/70 hover:text-white hover:scale-110 active:scale-95 shadow-lg backdrop-blur-sm"
        aria-label={buttonAriaLabel}
        disabled={!isLoaded && !hasError}
        type="button"
      >
        {buttonIcon}
      </button>
    </>
  );
};

### .\src\components\core\ElementalGradient.tsx ###

// src/components/core/ElementalGradient.tsx

"use client";
import { Canvas, useFrame, extend } from '@react-three/fiber';
import { useRef } from 'react';
import * as THREE from 'three';
import { shaderMaterial } from '@react-three/drei';

const ElementalGradientMaterial = shaderMaterial(
  // Uniforms
  { u_time: 0 },
  // Vertex Shader
  ` varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }`,
  // Fragment Shader
  ` varying vec2 vUv;
    uniform float u_time;

    float random(vec2 p) { return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5453); }
    float noise(vec2 p) {
        vec2 i = floor(p); vec2 f = fract(p);
        vec2 u = f * f * (3.0 - 2.0 * f);
        return mix(mix(random(i), random(i + vec2(1.0, 0.0)), u.x),
                   mix(random(i + vec2(0.0, 1.0)), random(i + vec2(1.0, 1.0)), u.x), u.y);
    }

    void main() {
        vec2 p = vUv * 3.0 + u_time * 0.05;
        float value = noise(p);
        // Create a dark, subtle gradient effect from the noise
        vec3 color = vec3(smoothstep(0.4, 0.7, value)) * 0.15;
        gl_FragColor = vec4(color, 1.0);
    }`
);

extend({ ElementalGradientMaterial });

const Scene = () => {
    const materialRef = useRef<any>();
    useFrame((state, delta) => {
        if (materialRef.current) materialRef.current.uniforms.u_time.value += delta * 0.2;
    });
    return (
        <mesh scale={[2, 2, 2]}>
            <planeGeometry args={[1, 1]} />
            {/* @ts-ignore */}
            <elementalGradientMaterial ref={materialRef} />
        </mesh>
    );
};

export const ElementalGradient = () => (
    <div className="w-full h-full">
        <Canvas camera={{ position: [0, 0, 1] }}>
            <Scene />
        </Canvas>
    </div>
);

### .\src\components\core\FloatingParticlesBackground.tsx ###

// src/components/core/FloatingParticlesBackground.tsx

"use client";

// ADDED: useState and useEffect for the gyroscope
import React, { useMemo, useRef, useState, useEffect } from "react"; 
import { Canvas, useFrame, extend } from "@react-three/fiber";
import * as THREE from "three";
import { shaderMaterial } from "@react-three/drei";

// ===================================================================
// ==                          CONTROLS                             ==
// ===================================================================
const PARTICLE_CONTROLS = {
    quantity: 1500,
    size: 0.04,
    glowPercentage: 0.8,
    blinkPercentage: 0.2,
    direction: -1, 
    speed: 0.2,
    // ONLY ADDITION: A control for gyroscope sensitivity
    gyroIntensity: 1,
};
// ===================================================================

// Your custom shader material. THIS IS UNCHANGED.
const CustomParticleMaterial = shaderMaterial(
  { u_time: 0.0 },
  // Vertex Shader
  ` uniform float u_time;
    attribute vec3 a_color;
    attribute float a_blinkSpeed;
    varying vec3 v_color;
    varying float v_blinkSpeed;

    void main() {
      v_color = a_color;
      v_blinkSpeed = a_blinkSpeed;
      vec4 modelPosition = modelMatrix * vec4(position, 1.0);
      vec4 viewPosition = viewMatrix * modelPosition;
      gl_PointSize = ${PARTICLE_CONTROLS.size} * (300.0 / -viewPosition.z);
      gl_Position = projectionMatrix * viewPosition;
    }`,
  // Fragment Shader
  ` uniform float u_time;
    varying vec3 v_color;
    varying float v_blinkSpeed;

    void main() {
      float dist = distance(gl_PointCoord, vec2(0.5));
      if (dist > 0.5) { discard; }
      float alpha = 1.0;
      if (v_blinkSpeed > 0.0) { alpha = (sin(u_time * v_blinkSpeed) + 1.0) / 2.0; }
      gl_FragColor = vec4(v_color, alpha);
    }`
);
extend({ CustomParticleMaterial });

// The particle system.
// ONLY CHANGE: It now accepts `gyroData` as a prop.
const Particles = ({ mousePosition, gyroData }: { mousePosition: { x: number, y: number }, gyroData: { x: number, y: number } }) => {
  const meshRef = useRef<THREE.Points>(null!);
  
  // Your particle generation logic. THIS IS UNCHANGED.
  const particleData = useMemo(() => {
    const positions = new Float32Array(PARTICLE_CONTROLS.quantity * 3);
    const colors = new Float32Array(PARTICLE_CONTROLS.quantity * 3);
    const blinkSpeeds = new Float32Array(PARTICLE_CONTROLS.quantity);
    const distance = 10;
    for (let i = 0; i < PARTICLE_CONTROLS.quantity; i++) {
      positions[i * 3 + 0] = (Math.random() - 0.5) * distance;
      positions[i * 3 + 1] = (Math.random() - 0.5) * distance;
      positions[i * 3 + 2] = (Math.random() - 0.5) * distance;
      let particleColor = new THREE.Color();
      blinkSpeeds[i] = 0.0;
      if (Math.random() < PARTICLE_CONTROLS.blinkPercentage) {
        particleColor.setHSL(0, 0, 1.0);
        blinkSpeeds[i] = Math.random() * 3 + 1;
      } else if (Math.random() < PARTICLE_CONTROLS.glowPercentage) {
        particleColor.setHSL(0, 0, 1.0);
      } else {
        const shade = 0.4 + Math.random() * 0.2;
        particleColor.setHSL(0, 0, shade);
      }
      colors.set([particleColor.r, particleColor.g, particleColor.b], i * 3);
    }
    return { positions, colors, blinkSpeeds };
  }, []);

  useFrame((state, delta) => {
    // --- GYROSCOPE INTEGRATION LOGIC ---
    // 1. Check if gyroscope is active.
    const hasGyro = gyroData.x !== 0 || gyroData.y !== 0;
    
    // 2. Use gyro data if available, otherwise fall back to mouse data.
    const targetX = hasGyro ? gyroData.x * PARTICLE_CONTROLS.gyroIntensity : mousePosition.x * 0.5;
    const targetY = hasGyro ? gyroData.y * PARTICLE_CONTROLS.gyroIntensity : mousePosition.y * 0.5;

    // 3. Your original camera movement logic, now driven by either gyro or mouse.
    state.camera.position.x = THREE.MathUtils.lerp(state.camera.position.x, targetX, 0.05);
    state.camera.position.y = THREE.MathUtils.lerp(state.camera.position.y, targetY, 0.05);
    
    // Your infinite loop animation. THIS IS UNCHANGED.
    if (meshRef.current) {
      const positions = meshRef.current.geometry.attributes.position.array as Float32Array;
      for (let i = 0; i < positions.length; i += 3) {
        positions[i + 2] += delta * PARTICLE_CONTROLS.speed * PARTICLE_CONTROLS.direction;
        if (PARTICLE_CONTROLS.direction === 1 && positions[i + 2] > 5) {
            positions[i + 2] = -5;
            positions[i] = (Math.random() - 0.5) * 10;
            positions[i + 1] = (Math.random() - 0.5) * 10;
        } else if (PARTICLE_CONTROLS.direction === -1 && positions[i + 2] < -5) {
            positions[i + 2] = 5;
            positions[i] = (Math.random() - 0.5) * 10;
            positions[i + 1] = (Math.random() - 0.5) * 10;
        }
      }
      meshRef.current.geometry.attributes.position.needsUpdate = true;
      (meshRef.current.material as THREE.ShaderMaterial).uniforms.u_time.value = state.clock.getElapsedTime();
    }
  });

  return (
    // Your JSX for the particles. THIS IS UNCHANGED.
    <points ref={meshRef}>
        <bufferGeometry>
            <bufferAttribute attach="attributes-position" count={particleData.positions.length / 3} array={particleData.positions} itemSize={3} />
            <bufferAttribute attach="attributes-a_color" count={particleData.colors.length / 3} array={particleData.colors} itemSize={3} />
            <bufferAttribute attach="attributes-a_blinkSpeed" count={particleData.blinkSpeeds.length} array={particleData.blinkSpeeds} itemSize={1} />
        </bufferGeometry>
        {/* @ts-ignore */}
        <customParticleMaterial 
            attach="material"
            blending={THREE.AdditiveBlending}
            transparent={true}
            depthWrite={false}
            vertexColors={true}
        />
    </points>
  );
};

// --- GYROSCOPE LOGIC ADDED HERE ---
export const FloatingParticlesBackground = ({ mousePosition, gyroData }: { mousePosition: { x: number, y: number }, gyroData: { x: number, y: number } }) => {

  const [internalGyroData, setInternalGyroData] = useState({ x: 0, y: 0 });

  useEffect(() => {
    const handleDeviceOrientation = (event: DeviceOrientationEvent) => {
      const { beta, gamma } = event;
      if (beta !== null && gamma !== null) {
        const x = THREE.MathUtils.clamp(gamma / 90, -1, 1);
        const y = THREE.MathUtils.clamp(beta / 90, -1, 1);
        setInternalGyroData({ x, y });
      }
    };
    
    if (typeof window !== 'undefined' && window.DeviceOrientationEvent) {
      window.addEventListener('deviceorientation', handleDeviceOrientation);
    }

    return () => {
      if (typeof window !== 'undefined' && window.DeviceOrientationEvent) {
        window.removeEventListener('deviceorientation', handleDeviceOrientation);
      }
    };
  }, []);

  return (
    <div className="fixed inset-0 z-0">
      <Canvas camera={{ position: [0, 0, 5], fov: 75 }}>
        {/* We now pass both mouse and gyro data down */}
        <Particles mousePosition={mousePosition} gyroData={internalGyroData} />
      </Canvas>
    </div>
  );
};

### .\src\components\core\Footer.tsx ###

// src/components/core/Footer.tsx
"use client";
import Link from 'next/link';

const InstagramIcon = () => (
  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line></svg>
);

export const Footer = () => {
  const currentYear = new Date().getFullYear();

  return (
    <footer className="w-full bg-black z-40 relative px-6 md:px-12 py-8 border-t border-white/10">
      <div className="max-w-7xl mx-auto flex flex-col md:flex-row justify-between items-center text-sm text-white/50">
        {/* Left: Copyright */}
        <div className="mb-4 md:mb-0">
          Â© {currentYear} SWAMBASIC. All Rights Reserved.
        </div>
        
        {/* Right: Social & Legal Links */}
        <div className="flex items-center gap-4 md:gap-8 flex-wrap justify-center">
            <a href="https://www.instagram.com/swambasic/" target="_blank" rel="noopener noreferrer" className="hover:text-white transition-colors"><InstagramIcon /></a>
            <div className="w-px h-4 bg-white/20 hidden md:block"></div>
            {/* --- THIS IS THE FIX --- */}
            <div className="flex items-center gap-4 md:gap-6 font-sans uppercase tracking-wider text-xs flex-wrap justify-center">
                <Link href="/terms" className="hover:text-white transition-colors">Terms</Link>
                <Link href="/privacy" className="hover:text-white transition-colors">Privacy</Link>
                <Link href="/shipping" className="hover:text-white transition-colors">Shipping</Link>
                <Link href="/refunds" className="hover:text-white transition-colors">Refunds</Link>
                <Link href="/reach-out" className="hover:text-white transition-colors">Contact Us</Link>
            </div>
        </div>
      </div>
    </footer>
  );
};

### .\src\components\core\FullScreenImageViewer.tsx ###

// src/components/core/FullScreenImageViewer.tsx

"use client";

import { motion, AnimatePresence } from 'framer-motion';
import Image from 'next/image';

interface FullScreenImageViewerProps {
  imageUrl: string | null;
  onClose: () => void;
}

const getOptimizedShopifyImageUrl = (url: string, size: number) => {
    if (!url) return '';
    try {
        const urlObj = new URL(url);
        const extension = urlObj.pathname.split('.').pop();
        const pathWithoutExtension = urlObj.pathname.substring(0, urlObj.pathname.lastIndexOf('.'));
        return `${urlObj.origin}${pathWithoutExtension}_${size}x.${extension}`;
    } catch (e) { return url; }
};

export const FullScreenImageViewer = ({ imageUrl, onClose }: FullScreenImageViewerProps) => {
    return (
        <AnimatePresence>
            {imageUrl && (
                <motion.div
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    exit={{ opacity: 0 }}
                    onClick={onClose}
                    className="fixed inset-0 bg-black/80 backdrop-blur-lg z-50 flex items-center justify-center p-4 cursor-zoom-out"
                >
                    <motion.div 
                        layoutId={`product-image-${imageUrl}`}
                        className="relative w-full h-full max-w-4xl max-h-[80vh]"
                    >
                        <Image
                            src={getOptimizedShopifyImageUrl(imageUrl, 1600)}
                            alt="Full screen product view"
                            fill
                            className="object-contain"
                            quality={90}
                        />
                    </motion.div>
                </motion.div>
            )}
        </AnimatePresence>
    );
};

### .\src\components\core\GlitchTextureBackground.tsx ###

// src/components/core/GlitchTextureBackground.tsx

"use client";
import { Canvas, useFrame, extend } from '@react-three/fiber';
import { useRef } from 'react';
import * as THREE from 'three';
import { shaderMaterial } from '@react-three/drei';

const GlitchMaterial = shaderMaterial(
  // Uniforms
  {
    u_time: 0,
    u_intensity: 0.0,
  },
  // Vertex Shader
  ` varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }`,
  // Fragment Shader
  ` varying vec2 vUv;
    uniform float u_time;
    uniform float u_intensity;

    float random (vec2 st) {
      return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
    }

    void main() {
      vec2 uv = vUv;
      float time = u_time * 0.1;

      // 1. Base Grain (always present)
      float grain = random(uv * (1.0 + u_intensity * 2.0) + time) * 0.10;
      vec3 color = vec3(grain * 0.5);

      // 2. Scan Lines (driven by intensity)
      float scanline = sin(uv.y * 800.0 - time * 500.0) * u_intensity * 0.05;
      color += scanline;

      // 3. Blocky Glitch (driven by intensity)
      if (random(vec2(time, 2.0)) < u_intensity * 0.1) {
        float block_y = floor(uv.y * (10.0 + u_intensity * 20.0)) / (10.0 + u_intensity * 20.0);
        float displacement = random(vec2(block_y, time)) * u_intensity * 0.2;
        if (displacement > 0.05) {
           color += vec3(displacement * 0.1);
        }
      }

      gl_FragColor = vec4(color, 1.0);
    }`
);

extend({ GlitchMaterial });

const Scene = ({ glitchIntensity }: { glitchIntensity: number }) => {
    const materialRef = useRef<any>();
    
    useFrame((state, delta) => {
        if (materialRef.current) {
            materialRef.current.uniforms.u_time.value += delta;
            materialRef.current.uniforms.u_intensity.value = THREE.MathUtils.lerp(
                materialRef.current.uniforms.u_intensity.value,
                glitchIntensity,
                0.1 
            );
        }
    });

    return (
        <mesh>
            <planeGeometry args={[2, 2]} />
            {/* @ts-ignore */}
            <glitchMaterial ref={materialRef} key={GlitchMaterial.key} />
        </mesh>
    );
}

export const GlitchTextureBackground = ({ intensity }: { intensity: number }) => {
    return (
        <div className="fixed inset-0 z-[-1] bg-black">
            <Canvas camera={{ position: [0, 0, 1] }}>
                <Scene glitchIntensity={intensity} />
            </Canvas>
        </div>
    );
};

### .\src\components\core\GlobalSoundEffects.tsx ###

"use client";

import { useEffect, useRef } from 'react';

/**
 * This component attaches global event listeners to play sounds
 * for universal actions like clicking and typing anywhere on the page.
 * 
 * LATENCY FIX: Audio objects are now pre-loaded and reused via useRef.
 * On each event, we rewind the audio to the start (`currentTime = 0`) and play,
 * eliminating the delay of creating a new Audio() object each time.
 */
export const GlobalSoundEffects = () => {
  const clickSoundRef = useRef<HTMLAudioElement | null>(null);
  const typingSoundRef = useRef<HTMLAudioElement | null>(null);

  // Effect to pre-load the audio objects on component mount
  useEffect(() => {
    // Check if window is defined to ensure this runs only on the client
    if (typeof window !== 'undefined') {
        clickSoundRef.current = new Audio('/audio/typing.wav');
      clickSoundRef.current.volume = 0.5;

      typingSoundRef.current = new Audio('/audio/typing.wav');
      typingSoundRef.current.volume = 0.4;
    }
  }, []); // Empty dependency array ensures this runs only once

  useEffect(() => {
    const handleMouseDown = () => {
      if (clickSoundRef.current) {
        clickSoundRef.current.currentTime = 0.1; // Rewind to start
        clickSoundRef.current.play().catch(e => console.error("Could not play click sound:", e));
      }
    };

    const handleKeyDown = (event: KeyboardEvent) => {
      // Add null check for event.key before accessing its properties
      if (!event.key) return;
      
      const isTypingKey = event.key.length === 1 || event.key === 'Backspace';
      if (isTypingKey && typingSoundRef.current) {
        typingSoundRef.current.currentTime = 0; // Rewind to start
        typingSoundRef.current.play().catch(e => console.error("Could not play typing sound:", e));
      }
    };

    document.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('keydown', handleKeyDown);

    return () => {
      document.removeEventListener('mousedown', handleMouseDown);
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, []); // We don't need dependencies as the refs are stable

  return null;
};

### .\src\components\core\Header.tsx ###

// src/components/core/Header.tsx

"use client";
import Link from 'next/link';
import { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useCartNotification } from '@/hooks/useCartNotification';

const UserIcon = () => ( <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg> );
const CartIcon = () => {
    const { cartCount } = useCartNotification();
    return ( <div className="relative"> <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"><circle cx="9" cy="21" r="1"></circle><circle cx="20" cy="21" r="1"></circle><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path></svg> {cartCount > 0 && ( <div className="absolute -top-2 -right-2 w-5 h-5 bg-white text-black text-xs font-bold rounded-full flex items-center justify-center"> {cartCount} </div> )} </div> );
};
const MenuIcon = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>;
const CloseIcon = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>;

export const Header = () => {
    const [isMenuOpen, setIsMenuOpen] = useState(false);

    return (
        <>
            <header className="fixed top-0 left-0 w-full z-50 p-4 md:p-6">
                <div className="mx-auto max-w-7xl px-4 md:px-6 py-4 rounded-3xl border border-white/10 bg-black/20 backdrop-blur-sm">
                    <nav className="relative flex items-center justify-between w-full">
                        <div className="flex items-center gap-8">
                            <div className="hidden md:flex items-center gap-8 font-sans text-sm uppercase tracking-wider text-white/80">
                                <Link href="/catalog" className="hover:text-white transition-colors">Catalog</Link>
                                <Link href="/reach-out" className="hover:text-white transition-colors">Reach Out</Link>
                            </div>
                            <div className="md:hidden">
                                <button onClick={() => setIsMenuOpen(true)} className="text-white"> <MenuIcon /> </button>
                            </div>
                        </div>
                        <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 -ml-4">
                            <Link href="/home">
                                <span className="font-display font-bold text-white text-xl md:text-2xl" style={{ textShadow: '0 0 15px rgba(255, 255, 255, 1)' }}>SWAMBASIC</span>
                            </Link>
                        </div>
                        <div className="flex justify-end items-center gap-6 md:gap-8 text-white/80">
                            <Link href="/account" className="hover:text-white transition-colors"><UserIcon /></Link>
                            <Link href="/cart" className="hover:text-white transition-colors"><CartIcon /></Link>
                        </div>
                    </nav>
                </div>
            </header>

            <AnimatePresence>
                {isMenuOpen && (
                    <motion.div
                        initial={{ opacity: 0, y: -20 }}
                        animate={{ opacity: 1, y: 0 }}
                        exit={{ opacity: 0, y: -20 }}
                        className="md:hidden fixed top-24 left-4 right-4 bg-black/50 backdrop-blur-xl border border-white/10 rounded-2xl z-[100] p-6 shadow-2xl"
                    >
                        {/* --- THIS IS THE FIX: onClick handlers are restored --- */}
                        <nav className="flex flex-col items-start gap-4 text-white font-sans text-lg uppercase">
                            <Link href="/catalog" onClick={() => setIsMenuOpen(false)} className="w-full py-2">Catalog</Link>
                            <Link href="/reach-out" onClick={() => setIsMenuOpen(false)} className="w-full py-2">Reach Out</Link>
                        </nav>
                    </motion.div>
                )}
            </AnimatePresence>
        </>
    );
};

### .\src\components\core\InteractiveLiquidBackground.tsx ###

"use client";
import * as THREE from 'three';
import { Canvas, useFrame, extend, useThree } from '@react-three/fiber';
import { useRef } from 'react';
import { shaderMaterial } from '@react-three/drei';

const vertexShader = `
  varying vec2 vUv;
  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;

const fragmentShader = `
  varying vec2 vUv;
  uniform float u_time;
  uniform vec2 u_mouse;
  uniform vec2 u_mouse_velocity;
  uniform float u_mouse_strength;

  float random (vec2 st) {
      return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
  }

  float noise (vec2 st) {
      vec2 i = floor(st);
      vec2 f = fract(st);
      float a = random(i);
      float b = random(i + vec2(1.0, 0.0));
      float c = random(i + vec2(0.0, 1.0));
      float d = random(i + vec2(1.0, 1.0));
      vec2 u = f*f*(3.0-2.0*f);
      return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
  }

  void main() {
    float dist = distance(vUv, u_mouse);
    
    // Create water-like disturbance around cursor
    float influence = smoothstep(0.5, 0.0, dist);
    
    // Mouse velocity creates flow direction - like water following object
    vec2 flow_direction = u_mouse_velocity * 10.0;
    vec2 mouse_flow = flow_direction * influence * u_mouse_strength;
    
    // Create ripple effect from mouse movement
    float ripple_intensity = u_mouse_strength * influence;
    vec2 ripple_offset = sin(vec2(dist * 20.0 - u_time * 5.0)) * ripple_intensity * 0.02;
    
    // Combine all distortions
    vec2 base_uv = vUv * vec2(2.0, 1.0) + vec2(u_time * 0.05);
    vec2 disturbed_uv = base_uv + mouse_flow + ripple_offset;
    
    float n1 = noise(disturbed_uv * 2.0 + u_time * 0.1);
    float n2 = noise(disturbed_uv * 4.0 - u_time * 0.2);
    
    // Add extra noise disturbance around mouse
    float extra_noise = noise((vUv + mouse_flow * 0.5) * 8.0) * influence * 0.3;
    
    float combined_noise = (n1 + n2) * 0.5 + extra_noise;
    
    // Glow effect
    float glow = influence * u_mouse_strength * 0.2;
    
    vec3 color1 = vec3(0.0, 0.0, 0.0);
    vec3 color2 = vec3(0.1, 0.1, 0.1);
    vec3 color3 = vec3(0.25, 0.25, 0.25);
    
    vec3 color = mix(color1, color2, smoothstep(0.3, 0.6, combined_noise));
    color = mix(color, color3, smoothstep(0.6, 0.8, combined_noise));
    
    // Add glow
    color += glow;

    gl_FragColor = vec4(color, 1.0);
  }
`;

const LiquidGradientMaterial = shaderMaterial(
  // We initialize the mouse uniform at the center (0.5, 0.5 in UV space)
  { u_time: 0, u_mouse: new THREE.Vector2(0.5, 0.5) },
  vertexShader,
  fragmentShader
);

extend({ LiquidGradientMaterial });

function Scene() {
  const materialRef = useRef<any>();
  const { viewport } = useThree();

  useFrame((state, delta) => {
    if (materialRef.current) {
      materialRef.current.uniforms.u_time.value += delta;

      // THE FIX IS HERE:
      // 1. We get the pointer position from the state (-1 to 1 range).
      // 2. We convert it to UV coordinates (0 to 1 range).
      // 3. We smoothly move the shader's mouse uniform to this correct coordinate.
      const targetMouse = new THREE.Vector2(
        (state.pointer.x + 1) / 2,
        (-state.pointer.y + 1) / 2
      );
      materialRef.current.uniforms.u_mouse.value.lerp(targetMouse, 0.5);
    }
  });

  return (
    <mesh>
      <planeGeometry args={[viewport.width, viewport.height]} />
      <liquidGradientMaterial ref={materialRef} />
    </mesh>
  );
}

export const InteractiveLiquidBackground = () => {
  return (
    <div
      style={{
        position: 'fixed',
        top: 0,
        left: 0,
        width: '100vw',
        height: '100vh',
        zIndex: -10,
        background: 'black',
      }}
    >
      <Canvas camera={{ position: [0, 0, 1] }}>
        <Scene />
      </Canvas>
    </div>
  );
};


### .\src\components\core\LiquidGradient.tsx ###

"use client";
import { Canvas, useFrame } from '@react-three/fiber';
import { useRef } from 'react';
import * as THREE from 'three';
import { shaderMaterial } from '@react-three/drei';
import { extend } from '@react-three/fiber';

const LiquidShaderMaterial = shaderMaterial(
  { u_time: 0 },
  ` varying vec2 vUv;
    void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
  ` varying vec2 vUv;
    uniform float u_time;
    float random(vec2 p) { return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5453); }
    float noise(vec2 p) {
        vec2 i = floor(p); vec2 f = fract(p);
        vec2 u = f * f * (3.0 - 2.0 * f);
        return mix(mix(random(i), random(i + vec2(1.0, 0.0)), u.x),
                   mix(random(i + vec2(0.0, 1.0)), random(i + vec2(1.0, 1.0)), u.x), u.y);
    }
    float fbm(vec2 p) {
        float value = 0.0; float amplitude = 0.5;
        for (int i = 0; i < 2; i++) { value += amplitude * noise(p); p *= 2.0; amplitude *= 0.5; }
        return value;
    }
    void main() {
        vec2 p = vUv * 5.0;
        float time_offset = u_time * 0.1;
        vec2 q = vec2(fbm(p + time_offset), fbm(p + time_offset + 1.0));
        float liquid = fbm(p + q);
        vec3 color = vec3(smoothstep(0.4, 0.6, liquid)) * 0.1; // Soft, dark light effect
        gl_FragColor = vec4(color, 1.0);
    }`
);
extend({ LiquidShaderMaterial });

function Scene() {
    const materialRef = useRef<any>();
    useFrame((state, delta) => {
        if (materialRef.current) {
            materialRef.current.uniforms.u_time.value += delta * 2;
        }
    });
    return (
        <mesh scale={2}>
            <planeGeometry args={[1, 1]} />
            <liquidShaderMaterial ref={materialRef} />
        </mesh>
    );
}

export const LiquidGradient = () => {
    return (
        <div className="absolute inset-0 z-0">
            <Canvas camera={{position: [0, 0, 1]}}>
                <Scene/>
            </Canvas>
        </div>
    )
}

### .\src\components\core\LiquidGrainBackground.tsx ###

// src/components/core/LiquidGrainBackground.tsx

"use client";

import { Canvas, useFrame, extend, useThree } from '@react-three/fiber';
import { useRef } from 'react';
import * as THREE from 'three';
import { shaderMaterial } from '@react-three/drei';

const LiquidGrainMaterial = shaderMaterial(
  { u_time: 0 },
  ` varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
  ` varying vec2 vUv; uniform float u_time;
    float random(vec2 p) { return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5453); }
    float noise(vec2 p) { vec2 i = floor(p); vec2 f = fract(p); vec2 u = f*f*(3.0-2.0*f); return mix(mix(random(i), random(i + vec2(1.0, 0.0)), u.x), mix(random(i + vec2(0.0, 1.0)), random(i + vec2(1.0, 1.0)), u.x), u.y); }
    float fbm(vec2 p) { float value = 0.0; float amplitude = 0.5; for (int i = 0; i < 3; i++) { value += amplitude * noise(p); p *= 2.0; amplitude *= 0.5; } return value; }
    void main() { 
      vec2 p = vUv * 2.5; 
      p.x += u_time * 0.2; 
      float noiseValue = fbm(p); 
      float grain = random(vUv * 1000.0) * 0.04; 
      float intensity = smoothstep(0.4, 0.7, noiseValue); 
      float glow = pow(intensity, 0.5) * 0.3;
      vec3 color = vec3(intensity * 0.1 + 0.05 + grain + glow); 
      gl_FragColor = vec4(color, 1); 
    }`
);

extend({ LiquidGrainMaterial });

const Scene = () => {
    const materialRef = useRef<any>();
    const { viewport } = useThree();
    
    useFrame((state, delta) => { if (materialRef.current) materialRef.current.uniforms.u_time.value += delta; });
    
    return (
        <mesh scale={[viewport.width, viewport.height, 1]}>
            <planeGeometry args={[1, 1]} />
            {/* @ts-ignore */}
            <liquidGrainMaterial ref={materialRef} />
        </mesh>
    );
};

export const LiquidGrainBackground = () => (
    <div className="fixed inset-0 z-[-1]" style={{ filter: 'blur(8px)' }}>
        <Canvas camera={{ position: [0, 0, 1] }}>
            <Scene />
        </Canvas>
    </div>
);

### .\src\components\core\MotionPermissionPrompt.tsx ###

"use client";
import { useGyroscope } from '@/hooks/useGyroscope'; // <-- Use our new hook

const MotionIcon = () => (
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
        <path d="M10 3.2a9 9 0 1 0 10.8 10.8"/>
        <path d="M14 2.26A9.01 9.01 0 0 0 12 2a9 9 0 0 0-9.2 8.74"/>
        <path d="M22 12h-2.5"/>
        <path d="M6 12H2"/>
        <path d="M12 6V2"/>
        <path d="M12 22v-2.5"/>
    </svg>
);
export const MotionPermissionPrompt = () => {
    // Get the tools from our custom hook
    const { needsPermission, requestPermission } = useGyroscope();

    // If the device doesn't need permission, this will be false.
    if (!needsPermission) {
        return null;
    }

    return (
        <button
            onClick={requestPermission}
            className="fixed bottom-4 left-4 z-50 p-3 bg-white/10 text-white backdrop-blur-md rounded-full animate-pulse transition-all hover:bg-white/20"
            aria-label="Enable motion controls"
        >
            <MotionIcon />
        </button>
    );
};

### .\src\components\core\PolicyPageLayout.tsx ###

// src/components/core/PolicyPageLayout.tsx

import React from 'react';

interface PolicyPageLayoutProps {
  title: string;
  children: React.ReactNode;
}

export const PolicyPageLayout = ({ title, children }: PolicyPageLayoutProps) => {
  return (
    <main className="min-h-screen bg-black pt-40 pb-24 px-6 md:px-12">
      <div className="max-w-3xl mx-auto">
        <h1 className="font-display text-4xl md:text-5xl font-bold mb-12 border-b border-white/10 pb-6">
          {title}
        </h1>
        {/* The 'prose' classes automatically style the text for readability */}
        <div className="prose prose-invert prose-lg max-w-none font-sans text-white/70 prose-headings:text-white prose-headings:font-display">
          {children}
        </div>
      </div>
    </main>
  );
};

### .\src\components\core\SubtleSmokeBackground.tsx ###

// src/components/core/SubtleSmokeBackground.tsx

"use client";
import { Canvas, useFrame, extend } from '@react-three/fiber';
import { useRef } from 'react';
import * as THREE from 'three';
import { shaderMaterial } from '@react-three/drei';

// This is a new shader material for our background
const NebulaMaterial = shaderMaterial(
  // Uniforms: values we can pass from React to the shader
  { u_time: 0 },
  // Vertex Shader: positions the vertices (standard stuff)
  ` varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }`,
  // Fragment Shader: colors each pixel to create the smoke effect
  ` varying vec2 vUv;
    uniform float u_time;

    // Procedural noise function to create randomness
    float random(vec2 p) { return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5453); }

    float noise(vec2 p) {
        vec2 i = floor(p); vec2 f = fract(p);
        vec2 u = f * f * (3.0 - 2.0 * f);
        return mix(mix(random(i), random(i + vec2(1.0, 0.0)), u.x),
                   mix(random(i + vec2(0.0, 1.0)), random(i + vec2(1.0, 1.0)), u.x), u.y);
    }

    // Fractional Brownian Motion: stacking layers of noise for detail
    float fbm(vec2 p) {
        float value = 0.0; float amplitude = 0.5;
        for (int i = 0; i < 3; i++) { // 3 layers of noise
            value += amplitude * noise(p);
            p *= 2.0; amplitude *= 0.5;
        }
        return value;
    }

    void main() {
        // Animate over time and scale the effect
        vec2 p = vUv * 4.0 + vec2(u_time * 0.05);
        
        // Calculate the noise value
        float smoke = fbm(p);
        
        // Make the effect soft and dark
        vec3 color = vec3(smoothstep(0.4, 0.6, smoke)) * 0.08;
        
        gl_FragColor = vec4(color, 1.0);
    }`
);

// Make the new material available to R3F
extend({ NebulaMaterial });

function Scene() {
    const materialRef = useRef<any>();
    // Animate the u_time uniform
    useFrame((state, delta) => {
        if (materialRef.current) {
            materialRef.current.uniforms.u_time.value += delta * 0.3; // Control speed here
        }
    });
    return (
        <mesh scale={2}>
            <planeGeometry args={[1, 1]} />
            {/* @ts-ignore */}
            <nebulaMaterial ref={materialRef} />
        </mesh>
    );
}

// The final component that we will use
export const SubtleSmokeBackground = () => {
    return (
        <div className="absolute inset-0 z-[-1]">
            <Canvas camera={{ position: [0, 0, 1] }}>
                <Scene />
            </Canvas>
        </div>
    )
}

### .\src\components\modules\CountdownTimer.tsx ###

"use client";
import { useState, useEffect } from 'react';

const CountdownUnit = ({ value, label }: { value: string, label: string }) => (
    <div className="flex flex-col items-center">
        <span className="font-display font-black text-3xl md:text-6xl tracking-tighter">
            {value}
        </span>
        <span className="font-sans text-xs text-foreground/50 tracking-widest mt-1">
            {label}
        </span>
    </div>
);

const CountdownTimer = () => {
  // SET YOUR LAUNCH DATE HERE
  const launchDate = new Date("2025-08-15T12:00:00Z").getTime();
  const [timeLeft, setTimeLeft] = useState({ d: 0, h: 0, m: 0, s: 0 });

  useEffect(() => {
    const interval = setInterval(() => {
      const now = new Date().getTime();
      const distance = launchDate - now;

      if (distance < 0) {
        clearInterval(interval);
        return;
      }

      setTimeLeft({
        d: Math.floor(distance / (1000 * 60 * 60 * 24)),
        h: Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)),
        m: Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60)),
        s: Math.floor((distance % (1000 * 60)) / 1000),
      });
    }, 1000);
    return () => clearInterval(interval);
  }, [launchDate]);

  const pad = (num: number) => num.toString().padStart(2, '0');

  return (
    <div className="flex items-start gap-4 md:gap-8">
        <CountdownUnit value={pad(timeLeft.d)} label="DAYS" />
        <span className="font-display font-black text-4xl md:text-6xl text-foreground/50">:</span>
        <CountdownUnit value={pad(timeLeft.h)} label="HOURS" />
        <span className="font-display font-black text-4xl md:text-6xl text-foreground/50">:</span>
        <CountdownUnit value={pad(timeLeft.m)} label="MINS" />
        <span className="font-display font-black text-4xl md:text-6xl text-foreground/50">:</span>
        <CountdownUnit value={pad(timeLeft.s)} label="SECS" />
    </div>
  );
};

export default CountdownTimer;

### .\src\components\modules\GatewayAnimation.tsx ###

"use client";

import { motion } from "framer-motion";
import Image from 'next/image';
import { useMediaQuery } from "@/hooks/useMediaQuery";
import { useState, useEffect, useMemo, useCallback } from 'react';

// ==================================================================
// OPTIMIZED CONSTANTS AND VARIANTS
// ==================================================================

// Pre-computed variants for better performance
const DESKTOP_VARIANTS = {
  container: {
    hidden: {},
    visible: { transition: { delayChildren: 1.2, staggerChildren: 1.2 } },
  },
  logoContainer: {
    hidden: { width: 0, opacity: 0, scale: 0 },
    visible: {
      width: 'auto', 
      opacity: 1, 
      scale: 1,
      transition: { duration: 1.2, ease: "easeInOut" },
    },
  },
  image: {
    hidden: { rotate: -180 },
    visible: { rotate: 0, transition: { duration: 1, delay: 1.2 } }
  }
};

const MOBILE_VARIANTS = {
  container: {
    visible: {
      transition: {
        staggerChildren: 0.6,
      }
    }
  },
  logoContainer: {
    hidden: { opacity: 0, scale: 0.5 },
    visible: { opacity: 1, scale: 1, transition: { duration: 1.0, ease: "easeInOut", delay: 0.4 } }
  },
  logoRotation: {
    hidden: { rotate: -180 },
    visible: { rotate: 0, transition: { duration: 1.2, ease: "easeInOut" } }
  },
  text: {
    hidden: { y: "100%", opacity: 0 },
    visible: { y: 0, opacity: 1, transition: { duration: 0.8, ease: "easeInOut" } }
  }
};

// Pre-computed text split for desktop
const TEXT = "SWAMBASIC";
const TEXT_FIRST_PART = TEXT.slice(0, 4).split('');
const TEXT_SECOND_PART = TEXT.slice(4).split('');

// ==================================================================
// OPTIMIZED DESKTOP LAYOUT
// ==================================================================
const DesktopLayout = () => {
  // Memoized letter animations to prevent re-renders
  const firstPartLetters = useMemo(() => 
    TEXT_FIRST_PART.map((letter, index) => (
      <motion.span 
        key={`first-${index}`}
        className="inline-block" 
        initial={{ y: "100%" }} 
        animate={{ y: 0 }} 
        transition={{ duration: 0.5, delay: index * 0.1 }}
      >
        {letter}
      </motion.span>
    )), []
  );

  const secondPartLetters = useMemo(() => 
    TEXT_SECOND_PART.map((letter, index) => (
      <motion.span 
        key={`second-${index}`}
        className="inline-block" 
        initial={{ y: "100%" }} 
        animate={{ y: 0 }} 
        transition={{ duration: 0.5, delay: (4 + index) * 0.1 }}
      >
        {letter}
      </motion.span>
    )), []
  );

  return (
    <motion.div 
      layout
      className="flex items-center justify-center" 
      variants={DESKTOP_VARIANTS.container} 
      initial="hidden" 
      animate="visible"
    >
      <span className="font-heading text-4xl md:text-6xl font-extrabold tracking-widest uppercase overflow-hidden text-shadow-glow">
        {firstPartLetters}
      </span>
      <motion.div 
        className="flex items-center justify-center mx-3 md:mx-4" 
        variants={DESKTOP_VARIANTS.logoContainer}
      >
        <motion.div 
          variants={DESKTOP_VARIANTS.image} 
          className="relative w-36 h-36 md:w-56 md:h-56"
        >
          <Image 
            src="https://cdn.jsdelivr.net/gh/manankadel/swambasic@main/public/logo-rotating.GIF"

            alt="SWAMBASIC Logo" 
            fill 
            className="object-contain" 
            unoptimized={true}
            priority={true}
            loading="eager"
            sizes="(max-width: 768px) 144px, 224px"
          />
        </motion.div>
      </motion.div>
      <span className="font-heading text-4xl md:text-6xl font-extrabold tracking-widest uppercase overflow-hidden text-shadow-glow">
        {secondPartLetters}
      </span>
    </motion.div>
  );
};

// ==================================================================
// OPTIMIZED MOBILE LAYOUT
// ==================================================================
const MobileLayout = () => {
  return (
    <motion.div 
      className="flex flex-col items-center justify-center gap-0"
      initial="hidden"
      animate="visible"
      variants={MOBILE_VARIANTS.container}
    >
      <motion.div variants={MOBILE_VARIANTS.logoContainer}>
        <motion.div
          className="relative w-60 h-60"
          variants={MOBILE_VARIANTS.logoRotation}
        >
          <Image 
            src="https://cdn.jsdelivr.net/gh/manankadel/swambasic@main/public/logo-rotating.GIF"
 alt="SWAMBASIC Logo" 
            fill 
            className="object-contain" 
            unoptimized={true}
            priority={true}
            loading="eager"
            sizes="240px"
          />
        </motion.div>
      </motion.div>

      <div className="overflow-hidden">
        <motion.span 
          className="font-heading text-4xl font-extrabold tracking-widest uppercase inline-block text-shadow-glow"
          variants={MOBILE_VARIANTS.text}
        >
          {TEXT}
        </motion.span>
      </div>
    </motion.div>
  );
};

// ==================================================================
// OPTIMIZED MAIN COMPONENT
// ==================================================================
export const GatewayAnimation = () => {
  const isMobile = useMediaQuery('(max-width: 767px)');
  const [hasMounted, setHasMounted] = useState(false);

  // Optimized mount effect
  useEffect(() => {
    const timer = requestAnimationFrame(() => {
      setHasMounted(true);
    });
    return () => cancelAnimationFrame(timer);
  }, []);

  // Memoized layout component selection
  const LayoutComponent = useMemo(() => {
    if (!hasMounted) return null;
    return isMobile ? MobileLayout : DesktopLayout;
  }, [isMobile, hasMounted]);

  // Optimized placeholder with exact dimensions
  if (!hasMounted) {
    return (
      <div 
        className="h-[184px] md:h-[224px]" 
        style={{ 
          contain: 'layout style paint',
          willChange: 'auto'
        }} 
      />
    );
  }
  
  // Render with performance optimizations
  return (
    <div 
      style={{ 
        contain: 'layout style paint',
        willChange: 'transform, opacity'
      }}
    >
      {LayoutComponent && <LayoutComponent key={isMobile ? "mobile" : "desktop"} />}
    </div>
  );
};

### .\src\components\modules\WaitlistForm.tsx ###

"use client";
import { useState } from 'react';
import { motion } from 'framer-motion';
import { useSound } from '@/hooks/useSound';

export const WaitlistForm = () => {
  const [email, setEmail] = useState('');
  const [phone, setPhone] = useState('');
  const [status, setStatus] = useState<'idle' | 'loading' | 'success' | 'error'>('idle');
  const [message, setMessage] = useState('');
  const playHoverSound = useSound('/audio/hover.mp3', 0.3);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setStatus('loading');
    setMessage('');

    try {
      const response = await fetch('/api/waitlist', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, phone }),
      });

      // DEBUG: Log response details
      console.log('Response status:', response.status);
      console.log('Response ok:', response.ok);
      console.log('Response headers:', response.headers);

      // Check if response has content and is JSON
      let data = null;
      const contentType = response.headers.get('content-type');
      
      console.log('Content-Type:', contentType); // DEBUG
      
      if (contentType && contentType.includes('application/json')) {
        const text = await response.text();
        console.log('Response text:', text); // DEBUG
        
        if (text) {
          try {
            data = JSON.parse(text);
            console.log('Parsed data:', data); // DEBUG
          } catch (parseError) {
            console.error('Failed to parse JSON:', parseError);
            data = { error: 'Invalid response from server' };
          }
        }
      } else {
        // If it's not JSON, let's see what we got
        const text = await response.text();
        console.log('Non-JSON response text:', text);
      }

      console.log('Final data object:', data); // DEBUG

      if (response.ok) {
        console.log('Response was OK, setting success'); // DEBUG
        setStatus('success');
        setMessage("You're on the list. We'll be in touch.");
        setEmail('');
        setPhone('');
      } else {
        console.log('Response was NOT OK, setting error'); // DEBUG
        setStatus('error');
        setMessage(data?.error || `Server error: ${response.status}`);
      }
    } catch (error) {
      console.error('Network error:', error);
      setStatus('error');
      setMessage('Network error. Please try again.');
    }
  };

  return (
    <div className="w-full max-w-sm mt-4 text-center">
      {/* The main form is a flex column with a gap */}
      <form onSubmit={handleSubmit} className="flex flex-col items-stretch gap-4">
        
        {/* ================================================================== */}
        {/* NEW LAYOUT: A horizontal flex container for the inputs.          */}
        {/* ================================================================== */}
        <div className='flex flex-row gap-4'>
            {/* Input 1: Email (shorter width) */}
            <input
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              placeholder="Email"
              required
              // UPDATED: rounded-3xl and adjusted placeholder text
              className="h-11 w-1/2 flex-grow px-4 bg-white/5 border border-white/20 backdrop-blur-sm rounded-3xl focus:outline-none focus:border-white/50 transition-all duration-300 placeholder-foreground/50 font-sans"
              disabled={status === 'loading' || status === 'success'}
            />
            {/* Input 2: Phone (shorter width) */}
            <input
              type="tel"
              value={phone}
              onChange={(e) => setPhone(e.target.value)}
              placeholder="Phone"
              // UPDATED: rounded-3xl and adjusted placeholder text
              className="h-11 w-1/2 flex-grow px-4 bg-white/5 border border-white/20 backdrop-blur-sm rounded-3xl focus:outline-none focus:border-white/50 transition-all duration-300 placeholder-foreground/50 font-sans"
              disabled={status === 'loading' || status === 'success'}
            />
        </div>

        {/* The button is now a direct child of the flex column, placing it below */}
        <motion.button
          type="submit"
          disabled={status === 'loading' || status === 'success'}
          // UPDATED: rounded-3xl
          className="h-11 px-6 bg-white/10 border border-white/20 backdrop-blur-sm rounded-3xl font-sans font-semibold text-white transition-all duration-300 disabled:opacity-50 hover:border-white/40 hover:shadow-[0_0_20px_rgba(255,255,255,0.15)]"
          whileTap={{ scale: status !== 'loading' ? 0.95 : 1 }}
          onMouseEnter={playHoverSound}
        >
          {status === 'loading' ? '...' : 'Join The Waitlist'}
        </motion.button>
      </form>
      
      {message && (
        <p className={`mt-3 text-sm ${status === 'error' ? 'text-red-400' : 'text-green-400'}`}>
          {message}
        </p>
      )}
    </div>
  );
};

### .\src\components\modules\account\Addresses.tsx ###

"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
// THE FIX: We now import BOTH types from the centralized `types` file.
import { ShopifyAddress, NewAddressInput } from "@/types/shopify";

// AddressCard component remains the same
const AddressCard = ({ address }: { address: ShopifyAddress }) => (
  <div className="p-6 border border-white/10 rounded-lg">
    <p className="font-sans">
      {address.address1}<br />
      {address.address2 && <>{address.address2}<br /></>}
      {address.city}, {address.province} {address.zip}<br />
      {address.country}
    </p>
    <div className="mt-4 flex gap-4 font-sans text-xs uppercase tracking-wider">
      <button className="hover:text-white">Edit</button>
      <button className="hover:text-red-400">Delete</button>
    </div>
  </div>
);

interface AddressFormProps {
    onCancel: () => void;
    onFormSubmit: (addressData: NewAddressInput) => void;
}

const AddressForm = ({ onCancel, onFormSubmit }: AddressFormProps) => {
    // ... all the state and JSX for this component remains the same
    const [address1, setAddress1] = useState('');
    const [address2, setAddress2] = useState('');
    const [city, setCity] = useState('');
    const [province, setProvince] = useState('');
    const [country, setCountry] = useState('');
    const [zip, setZip] = useState('');

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        onFormSubmit({ address1, address2, city, province, country, zip });
    };

    return (
        <form onSubmit={handleSubmit} className="space-y-4 p-6 border border-white/10 rounded-lg">
            {/* ... form inputs ... */}
        </form>
    );
}

interface AddressesProps {
  addresses: ShopifyAddress[];
}

const Addresses = ({ addresses }: AddressesProps) => {
  // ... all the logic and JSX for this main component remains the same
  const router = useRouter();
  const [isAdding, setIsAdding] = useState(false);
  const [error, setError] = useState('');

  const handleAddNewAddress = async (addressData: NewAddressInput) => {
    setError('');
    const response = await fetch('/api/account/addAddress', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(addressData),
    });

    if (response.ok) {
        setIsAdding(false);
        router.refresh();
    } else {
        const result = await response.json();
        setError(result.error || 'Failed to add address.');
    }
  };

  return (
    <div className="max-w-lg space-y-8">
        {/* ... component JSX ... */}
    </div>
  );
};

export default Addresses;

### .\src\components\modules\account\LoginRegister.tsx ###

"use client";

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { motion } from 'framer-motion';

// This is the same reusable input component from before
const FormInput = ({ label, type, id, value, onChange }: { label: string; type: string; id: string; value: string; onChange: (e: React.ChangeEvent<HTMLInputElement>) => void; }) => (
  <div>
    <label htmlFor={id} className="font-sans text-xs uppercase tracking-wider text-white/50">
      {label}
    </label>
    <input
      type={type}
      id={id}
      name={id}
      value={value}
      onChange={onChange}
      required
      autoComplete={type === 'password' ? (id === 'password' ? 'current-password' : 'new-password') : 'email'}
      className="mt-2 w-full px-4 py-3 bg-white/5 border border-white/20 rounded-md focus:outline-none focus:border-white/50 transition-colors font-sans"
    />
  </div>
);

const LoginRegister = () => {
  const [isLoginView, setIsLoginView] = useState(true);
  const [formData, setFormData] = useState({ firstName: '', lastName: '', email: '', password: '' });
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setFormData({ ...formData, [e.target.name]: e.target.value });
    setError(null); // Clear error on new input
  };

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);

    const endpoint = isLoginView ? '/api/auth/login' : '/api/auth/register';
    
    try {
      const response = await fetch(endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData),
      });

      const result = await response.json();

      if (!response.ok) {
        throw new Error(result.error || 'Something went wrong');
      }

      if (isLoginView) {
        // On successful login, redirect to the main account page
        router.push('/account');
      } else {
        // On successful registration, switch to the login view with a success message
        setIsLoginView(true);
        setError("Account created successfully. Please sign in.");
      }

    } catch (err: any) {
      setError(err.message);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="max-w-md mx-auto">
      <h1 className="font-display text-4xl md:text-5xl font-bold mb-8 text-center">
        {isLoginView ? 'Sign In' : 'Create Account'}
      </h1>

      <form onSubmit={handleSubmit} className="space-y-6">
        <motion.div
          key={isLoginView ? 'login' : 'register'}
          initial={{ opacity: 0, y: 10 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
          className="space-y-6"
        >
          {!isLoginView && (
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <FormInput label="First Name" type="text" id="firstName" value={formData.firstName} onChange={handleInputChange} />
              <FormInput label="Last Name" type="text" id="lastName" value={formData.lastName} onChange={handleInputChange} />
            </div>
          )}
          <FormInput label="Email Address" type="email" id="email" value={formData.email} onChange={handleInputChange} />
          <FormInput label="Password" type="password" id="password" value={formData.password} onChange={handleInputChange} />
        </motion.div>

        {error && (
            <p className={`text-sm text-center ${error.includes('successfully') ? 'text-green-400' : 'text-red-400'}`}>{error}</p>
        )}

        <div>
          <button
            type="submit"
            disabled={isLoading}
            className="w-full mt-4 px-8 py-3 bg-white text-black font-sans font-bold uppercase tracking-widest disabled:opacity-50 transition-opacity"
          >
            {isLoading ? 'Processing...' : (isLoginView ? 'Sign In' : 'Create Account')}
          </button>
        </div>
      </form>

      <div className="mt-8 text-center">
        <button onClick={() => { setIsLoginView(!isLoginView); setError(null); }} className="font-sans text-sm text-white/50 hover:text-white transition-colors">
          {isLoginView ? 'Need an account? Create one.' : 'Already have an account? Sign in.'}
        </button>
      </div>
    </div>
  );
};

export default LoginRegister;

### .\src\components\modules\account\OrderHistory.tsx ###

"use client";

// We import the real ShopifyOrder type
import { ShopifyOrder } from "@/types/shopify";
// THE FIX: Corrected the typo in the import statement.
import { format } from 'date-fns';

// Define the structure of the props we expect
interface OrderHistoryProps {
  orders: ShopifyOrder[];
}

const OrderCard = ({ order }: { order: ShopifyOrder }) => (
  <div className="p-6 border border-white/10 rounded-lg flex justify-between items-center transition-colors hover:bg-white/5">
    <div className="flex flex-col">
      <span className="font-display font-bold text-lg">#{order.orderNumber}</span>
      <span className="font-sans text-xs text-white/50 mt-1">
        {format(new Date(order.processedAt), 'MMMM dd, yyyy')}
      </span>
    </div>
    <div className="text-right">
      <span className={`font-sans text-xs uppercase tracking-widest px-2 py-1 rounded ${
        order.financialStatus === 'PAID' ? 'bg-green-500/10 text-green-400' : 'bg-yellow-500/10 text-yellow-400'
      }`}>
        {order.financialStatus}
      </span>
      <p className="font-mono text-lg mt-2">${parseFloat(order.totalPriceV2.amount).toFixed(2)}</p>
    </div>
  </div>
);

const OrderHistory = ({ orders }: OrderHistoryProps) => {
  if (orders.length === 0) {
    return (
      <div className="text-center py-10">
        <p className="font-sans text-white/50">You haven't placed any orders yet.</p>
      </div>
    );
  }

  return (
    <div className="flex flex-col gap-4">
      {orders.map(order => (
        <OrderCard key={order.id} order={order} />
      ))}
    </div>
  );
};

export default OrderHistory;

### .\src\components\modules\account\ProfileDetails.tsx ###

"use client";
import React, { useState } from 'react';
import { useRouter } from 'next/navigation';
import { ShopifyCustomer } from '@/types/shopify';

interface FormInputProps {
  label: string;
  type: string;
  id: string;
  value: string; // Changed to 'value' for controlled components
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
}

const FormInput = ({ label, type, id, value, onChange }: FormInputProps) => (
  <div>
    <label htmlFor={id} className="font-sans text-xs uppercase tracking-wider text-white/50">{label}</label>
    <input
      type={type}
      id={id}
      value={value}
      onChange={onChange}
      className="mt-2 w-full px-4 py-3 bg-white/5 border border-white/20 rounded-md focus:outline-none focus:border-white/50 transition-colors font-sans"
    />
  </div>
);

interface ProfileDetailsProps {
  customer: ShopifyCustomer | null;
}

const ProfileDetails = ({ customer }: ProfileDetailsProps) => {
  const router = useRouter();
  const [firstName, setFirstName] = useState(customer?.firstName || '');
  const [lastName, setLastName] = useState(customer?.lastName || '');
  const [isLoading, setIsLoading] = useState(false);
  const [message, setMessage] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setMessage('');

    const response = await fetch('/api/account/updateProfile', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ firstName, lastName }),
    });

    const data = await response.json();

    if (response.ok) {
        setMessage('Profile updated successfully!');
        // Refresh the page to show the new server-rendered data
        router.refresh();
    } else {
        setMessage(`Error: ${data.error}`);
    }
    setIsLoading(false);
  };

  if (!customer) {
    return <div>Loading profile...</div>;
  }

  return (
    <form onSubmit={handleSubmit} className="max-w-lg space-y-6">
      <h2 className="font-display text-3xl font-bold">Profile Details</h2>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <FormInput label="First Name" type="text" id="firstName" value={firstName} onChange={(e) => setFirstName(e.target.value)} />
        <FormInput label="Last Name" type="text" id="lastName" value={lastName} onChange={(e) => setLastName(e.target.value)} />
      </div>
      <FormInput label="Email Address" type="email" id="email" value={customer.email} onChange={() => {}} />
      <div>
        <button
          type="submit"
          disabled={isLoading}
          className="px-8 py-3 bg-white text-black font-sans font-bold uppercase tracking-widest disabled:opacity-50"
        >
          {isLoading ? 'Saving...' : 'Save Changes'}
        </button>
      </div>
      {message && <p className="mt-4 font-sans text-sm">{message}</p>}
    </form>
  );
};

export default ProfileDetails;

### .\src\components\modules\auth\AuthForm.tsx ###

// src/components/modules/auth/AuthForm.tsx

"use client";

import { useState } from 'react';
import { motion } from 'framer-motion';
import { useRouter } from 'next/navigation';

interface FormInputProps { id: string; label: string; type?: string; value: string; onChange: (e: React.ChangeEvent<HTMLInputElement>) => void; required?: boolean; disabled?: boolean; }
const FormInput = ({ id, label, type = "text", value, onChange, required = true, disabled = false }: FormInputProps) => (<div className="relative"><label htmlFor={id} className="font-sans text-xs uppercase tracking-wider text-white/60">{label}</label><input type={type} id={id} name={id} value={value} onChange={onChange} required={required} disabled={disabled} autoComplete={type === 'password' ? 'current-password' : 'email'} className="w-full mt-2 px-1 py-2 bg-transparent text-white border-b-2 border-white/20 focus:outline-none focus:border-white transition-colors font-sans disabled:opacity-50" /></div>);

export const AuthForm = () => {
    const router = useRouter();
    const [formType, setFormType] = useState<'login' | 'register'>('login');
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');
    const [loginEmail, setLoginEmail] = useState(''); const [loginPassword, setLoginPassword] = useState('');
    const [regFirstName, setRegFirstName] = useState(''); const [regLastName, setRegLastName] = useState('');
    const [regEmail, setRegEmail] = useState(''); const [regPassword, setRegPassword] = useState('');

    const handleApiSubmit = async (endpoint: string, body: Record<string, unknown>) => { setIsLoading(true); setError(''); try { const response = await fetch(endpoint, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) }); const data = await response.json(); if (!response.ok) throw new Error(data.error || 'Something went wrong'); router.push('/account'); router.refresh(); } catch (err: any) { setError(err.message); } finally { setIsLoading(false); } };
    const handleLoginSubmit = (e: React.FormEvent) => { e.preventDefault(); handleApiSubmit('/api/auth/login', { email: loginEmail, password: loginPassword }); };
    const handleRegisterSubmit = (e: React.FormEvent) => { e.preventDefault(); handleApiSubmit('/api/auth/register', { firstName: regFirstName, lastName: regLastName, email: regEmail, password: regPassword }); };
    const toggleFormType = (type: 'login' | 'register') => { if(!isLoading) { setFormType(type); setError(''); } };

    return (
        // ...but this div re-enables pointer events for itself and all its children.
        <div className="w-[80%] max-w-sm md:max-w-md mx-auto flex flex-col items-center pointer-events-auto">
            <div className="w-full h-[450px] md:h-[520px]" style={{ perspective: '1200px' }}>
                <motion.div
                    className="relative w-full h-full"
                    animate={{ rotateY: formType === 'login' ? 0 : 180 }}
                    transition={{ type: 'spring', stiffness: 200, damping: 25 }}
                    style={{ transformStyle: 'preserve-3d' }}
                >
                    {/* FRONT OF THE CARD (LOGIN) */}
                    <div className="absolute w-full h-full rounded-2xl border border-white/15 bg-white/5 backdrop-blur-xl shadow-2xl shadow-black/40" style={{ backfaceVisibility: 'hidden' }}>
                        <form onSubmit={handleLoginSubmit} className="relative z-10 w-full h-full p-10 flex flex-col justify-center space-y-10">
                            <h2 className="font-display text-2xl md:text-4xl font-bold text-center">Sign In</h2>
                            <FormInput id="login-email" label="Email" type="email" value={loginEmail} onChange={(e) => setLoginEmail(e.target.value)} disabled={isLoading} />
                            <FormInput id="login-password" label="Password" type="password" value={loginPassword} onChange={(e) => setLoginPassword(e.target.value)} disabled={isLoading} />
                            <button type="submit" disabled={isLoading} className="w-full mt-4 px-8 py-3 bg-white text-black font-sans font-bold uppercase tracking-widest hover:bg-white/80 transition-colors disabled:opacity-50">{isLoading && formType === 'login' ? '...' : 'Sign In'}</button>
                            <p className="text-center text-xs text-white/50">Don't have an account? <button type='button' onClick={() => toggleFormType('register')} className="font-bold hover:text-white transition">Create one</button>.</p>
                        </form>
                    </div>

                    {/* BACK OF THE CARD (REGISTER) */}
                    <div className="absolute w-full h-full rounded-2xl border border-white/15 bg-white/5 backdrop-blur-xl shadow-2xl shadow-black/40" style={{ backfaceVisibility: 'hidden', transform: 'rotateY(180deg)' }}>
                        <form onSubmit={handleRegisterSubmit} className="relative z-10 w-full h-full p-10 flex flex-col justify-center space-y-3">
                            <h2 className="font-display text-2xl md:text-4xl font-bold text-center">Join Us</h2>
                            <div className="grid grid-cols-2 gap-x-6">
                                <FormInput id="reg-firstName" label="First Name" value={regFirstName} onChange={(e) => setRegFirstName(e.target.value)} disabled={isLoading} />
                                <FormInput id="reg-lastName" label="Last Name" value={regLastName} onChange={(e) => setRegLastName(e.target.value)} disabled={isLoading} />
                            </div>
                            <FormInput id="reg-email" label="Email" type="email" value={regEmail} onChange={(e) => setRegEmail(e.target.value)} disabled={isLoading} />
                            <FormInput id="reg-password" label="Password" type="password" value={regPassword} onChange={(e) => setRegPassword(e.target.value)} disabled={isLoading} />
                            <button type="submit" disabled={isLoading} className="w-full mt-2 px-8 py-3 bg-white text-black font-sans font-bold uppercase tracking-widest hover:bg-white/80 transition-colors disabled:opacity-50">{isLoading && formType === 'register' ? '...' : 'Join'}</button>
                            <p className="text-center text-xs text-white/50">Already have an account? <button type='button' onClick={() => toggleFormType('login')} className="font-bold hover:text-white transition">Sign in</button>.</p>
                        </form>
                    </div>
                </motion.div>
            </div>
             
             <div className="h-6 mt-6 text-center">
                {error && <p className="text-sm text-red-400" role="alert">{error}</p>}
            </div>
        </div>
    );
};

### .\src\components\modules\catalog\CatalogClientWrapper.tsx ###

// src/components/modules/catalog/CatalogClientWrapper.tsx

"use client";

import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { ShopifyProductDetailed } from '@/types/shopify';
import { CatalogControls } from './CatalogControls';
import { ImmersiveView } from './ImmersiveView';
import { GridView } from './GridView';
import { LiquidGrainBackground } from '@/components/core/LiquidGrainBackground';
import { useMediaQuery } from '@/hooks/useMediaQuery';

const CollectionSplash = ({ onReveal, isClosing = false }: { onReveal: () => void; isClosing?: boolean }) => {
  const BAR_HEIGHT = 176;
  const isDesktop = useMediaQuery('(min-width: 640px)');

  const textContent = (
    <div className="text-center px-4">
      <div className="transform -translate-y-4 sm:-translate-y-10">
        <p className="font-sans uppercase tracking-widest text-lg sm:text-xl text-white/50 mb-6 sm:mb-8">Collection Vol. 1</p>
        <h1 className="font-display font-black text-6xl sm:text-8xl md:text-9xl lg:text-[10rem] leading-none">
          Sins  of
        </h1>
      </div>
      <div className="transform translate-y-4 sm:translate-y-10">
        <h1 className="font-display font-black text-6xl sm:text-8xl md:text-9xl lg:text-[10rem] leading-none">
          Saints
        </h1>
        <p className="font-sans uppercase tracking-widest text-lg sm:text-xl text-white/50 mt-8 sm:mt-12">
          Click to Explore The Collection.
        </p>
      </div>
    </div>
  );

  const clipPathOpen = 'polygon(0 0, 100% 0, 100% calc(50% - 88px), 0 calc(50% - 88px), 0 calc(50% + 88px), 100% calc(50% + 88px), 100% 100%, 0 100%)';
  const clipPathClosed = 'polygon(0 0, 100% 0, 100% 0, 0 0, 0 100%, 100% 100%, 100% 100%, 0 100%)';

  return (
    <motion.div
      key="splash"
      initial={isClosing ? {} : undefined}
      animate={isClosing ? {} : undefined}
      exit={{}}
      className="fixed inset-0 z-20 cursor-pointer overflow-hidden" // Changed to fixed positioning
      onClick={!isClosing ? onReveal : undefined}
    >
      {/* Top panel */}
      <motion.div 
        initial={isClosing ? { y: '-100%' } : undefined} 
        animate={isClosing ? { y: 0 } : undefined} 
        exit={!isClosing ? { y: '-100%' } : undefined} 
        transition={{ 
          duration: isDesktop ? 1.2 : 0.6, // Faster on mobile
          ease: [0.76, 0, 0.24, 1] 
        }} 
        className="absolute top-0 left-0 w-full bg-black border-b border-white/20 will-change-transform"
        style={{ 
          height: `calc(50% - ${BAR_HEIGHT / 2}px)`,
          transform: 'translateZ(0)'
        }} 
      />
      
      {/* Bottom panel */}
      <motion.div 
        initial={isClosing ? { y: '100%' } : undefined} 
        animate={isClosing ? { y: 0 } : undefined} 
        exit={!isClosing ? { y: '100%' } : undefined} 
        transition={{ 
          duration: isDesktop ? 1.2 : 0.6, // Faster on mobile
          ease: [0.76, 0, 0.24, 1] 
        }} 
        className="absolute bottom-0 left-0 w-full bg-black border-t border-white/20 will-change-transform"
        style={{ 
          height: `calc(50% - ${BAR_HEIGHT / 2}px)`,
          transform: 'translateZ(0)'
        }} 
      />
      
      {/* Text content with clipping */}
      <motion.div 
        className="absolute inset-0 grid place-items-center text-black overflow-hidden"
        style={{ 
          clipPath: isDesktop ? clipPathOpen : 'none',
          transform: 'translateZ(0)'
        }} 
        initial={isClosing && isDesktop ? { clipPath: clipPathClosed } : undefined}
        animate={isClosing && isDesktop ? { clipPath: clipPathOpen } : undefined}
        exit={!isClosing ? { 
          clipPath: isDesktop ? clipPathClosed : 'none',
          opacity: 0 
        } : undefined}
        transition={{ 
          duration: isDesktop ? 1.2 : 0.6, // Faster on mobile
          ease: [0.76, 0, 0.24, 1] 
        }}
      >
        {textContent}
      </motion.div>
      
      <motion.div 
        className="absolute inset-0 grid place-items-center text-white overflow-hidden"
        style={{ 
          mixBlendMode: 'difference', 
          clipPath: isDesktop ? clipPathOpen : 'none',
          transform: 'translateZ(0)'
        }}
        initial={isClosing && isDesktop ? { clipPath: clipPathClosed } : undefined}
        animate={isClosing && isDesktop ? { clipPath: clipPathOpen } : undefined}
        exit={!isClosing ? { 
          clipPath: isDesktop ? clipPathClosed : 'none',
          opacity: 0 
        } : undefined}
        transition={{ 
          duration: isDesktop ? 1.2 : 0.6, // Faster on mobile
          ease: [0.76, 0, 0.24, 1] 
        }}
      >
        {textContent}
      </motion.div>
    </motion.div>
  );
};

type ViewMode = 'immersive' | 'grid';
interface CatalogClientWrapperProps {
  products: ShopifyProductDetailed[];
}

export const CatalogClientWrapper = ({ products }: CatalogClientWrapperProps) => {
  const [isRevealed, setIsRevealed] = useState(false);
  const [isClosing, setIsClosing] = useState(false);
  const [viewMode, setViewMode] = useState<ViewMode>('immersive');
  const [focusedIndex, setFocusedIndex] = useState(0);

  // Manage scroll behavior during different states
  useEffect(() => {
    const html = document.documentElement;
    const body = document.body;
    
    if (!isRevealed || isClosing) {
      // During splash/closing: hide scroll completely
      html.style.overflow = 'hidden';
      body.style.overflow = 'hidden';
      html.classList.remove('catalog-revealed');
    } else {
      // Content revealed: enable scroll but hide scrollbar
      html.style.overflow = '';
      body.style.overflow = '';
      html.classList.add('catalog-revealed');
    }

    return () => {
      // Cleanup
      html.style.overflow = '';
      body.style.overflow = '';
      html.classList.remove('catalog-revealed');
    };
  }, [isRevealed, isClosing]);

  const handleGoBack = () => {
    setIsClosing(true);
    setTimeout(() => {
      setIsRevealed(false);
      setIsClosing(false);
    }, 1200);
  };

  return (
    <div className="relative"> {/* Remove min-h-screen constraint that was hiding footer */}
      {/* Background - always present */}
      <LiquidGrainBackground />
      
      {/* Splash screen overlay */}
      <AnimatePresence>
        {(!isRevealed || isClosing) && (
          <CollectionSplash onReveal={() => setIsRevealed(true)} isClosing={isClosing} />
        )}
      </AnimatePresence>
      
      {/* Main content - scrollable when revealed */}
      <AnimatePresence>
        {isRevealed && !isClosing && (
          <motion.div
            key="content"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1, transition: { duration: 0.6, delay: 0.4 } }} // Faster fade in
            exit={{ opacity: 0, transition: { duration: 0.3 } }} // Faster fade out
            className="relative z-10" // Remove min-h-screen to let content flow naturally
          >
            {viewMode === 'immersive' && (
              <ImmersiveView products={products} focusedIndex={focusedIndex} setFocusedIndex={setFocusedIndex} />
            )}
            {viewMode === 'grid' && <GridView products={products} />}
            <CatalogControls viewMode={viewMode} setViewMode={setViewMode} goBack={handleGoBack} />
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};

### .\src\components\modules\catalog\CatalogControls.tsx ###

// src/components/modules/catalog/CatalogControls.tsx

"use client";

type ViewMode = 'immersive' | 'grid';

interface CatalogControlsProps {
  viewMode: ViewMode;
  setViewMode: (mode: ViewMode) => void;
  goBack: () => void;
}

export const CatalogControls = ({ viewMode, setViewMode, goBack }: CatalogControlsProps) => {
  return (
    <div className="fixed bottom-8 left-8 z-50 flex items-center gap-4">
      <button 
        onClick={goBack}
        className="px-4 py-2 bg-black/30 backdrop-blur-sm rounded-full text-white font-sans text-sm hover:bg-white/20 transition-colors"
      >
        Back
      </button>
      <div className="flex bg-black/30 backdrop-blur-sm rounded-full p-1">
        <button
          onClick={() => setViewMode('immersive')}
          className={`px-4 py-1 rounded-full text-sm font-sans ${viewMode === 'immersive' ? 'bg-white text-black' : 'text-white'}`}
        >
          Focus
        </button>
        <button
          onClick={() => setViewMode('grid')}
          className={`px-4 py-1 rounded-full text-sm font-sans ${viewMode === 'grid' ? 'bg-white text-black' : 'text-white'}`}
        >
          Grid
        </button>
      </div>
    </div>
  );
};

### .\src\components\modules\catalog\GridView.tsx ###

// src/components/modules/catalog/GridView.tsx

"use client";

import { useState, useMemo, useRef, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { ShopifyProductDetailed } from '@/types/shopify';
import { InteractiveProductCard } from '@/components/modules/products/InteractiveProductCard';

const ChevronDown = () => ( <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg> );

const sortOptions = [
    { key: 'FEATURED', label: 'Sort: Featured' },
    { key: 'PRICE_LOW_TO_HIGH', label: 'Price: Low to High' },
    { key: 'PRICE_HIGH_TO_LOW', label: 'Price: High to Low' },
];

interface GridViewProps {
  products: ShopifyProductDetailed[];
}

export const GridView = ({ products }: GridViewProps) => {
  const [sortKey, setSortKey] = useState(sortOptions[0].key);
  
  // --- FIX: Logic for the custom dropdown is now embedded here ---
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);
  // --- END OF DROPDOWN LOGIC ---

  const sortedProducts = useMemo(() => {
    const newArray = [...products];
    switch (sortKey) {
      case 'PRICE_LOW_TO_HIGH':
        return newArray.sort((a, b) => parseFloat(a.priceRange.minVariantPrice.amount) - parseFloat(b.priceRange.minVariantPrice.amount));
      case 'PRICE_HIGH_TO_LOW':
        return newArray.sort((a, b) => parseFloat(b.priceRange.minVariantPrice.amount) - parseFloat(a.priceRange.minVariantPrice.amount));
      default:
        return products;
    }
  }, [products, sortKey]);

  const selectedOption = sortOptions.find(opt => opt.key === sortKey) || sortOptions[0];

  return (
    <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} className="p-6 md:p-12 pt-32 md:pt-40">
      <div className="max-w-7xl mx-auto mb-12 flex flex-col md:flex-row justify-between items-start md:items-center gap-8">
        <h1 className="font-display text-4xl font-bold">The Collection</h1>
        
        {/* --- FIX: The custom dropdown UI is now directly here --- */}
        <div className="relative w-full md:w-48" ref={dropdownRef}>
          <button onClick={() => setIsOpen(!isOpen)} className="w-full flex items-center justify-between bg-black/20 border border-white/10 rounded-lg px-4 py-2 text-sm font-sans focus:outline-none transition-colors hover:border-white/30">
            <span>{selectedOption.label}</span>
            <motion.div animate={{ rotate: isOpen ? 180 : 0 }}> <ChevronDown /> </motion.div>
          </button>
          <AnimatePresence>
            {isOpen && (
              <motion.div initial={{ opacity: 0, y: -10 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: -10 }} className="absolute top-full right-0 mt-2 w-full bg-black/50 border border-white/10 rounded-lg backdrop-blur-xl shadow-lg z-30 overflow-hidden">
                {sortOptions.map((option) => (
                  <button key={option.key} onClick={() => { setSortKey(option.key); setIsOpen(false); }} className="w-full text-left px-4 py-2 text-sm font-sans hover:bg-white/10 transition-colors">
                    {option.label}
                  </button>
                ))}
              </motion.div>
            )}
          </AnimatePresence>
        </div>
        {/* --- END OF DROPDOWN UI --- */}
      </div>

      <div className="max-w-7xl mx-auto grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-x-8 gap-y-12">
        {sortedProducts.map((product) => (
          <InteractiveProductCard key={product.id} product={product} />
        ))}
      </div>
    </motion.div>
  );
};

### .\src\components\modules\catalog\ImmersiveView.tsx ###

// src/components/modules/catalog/ImmersiveView.tsx

"use client";

import { useState, useMemo, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { motion, AnimatePresence, PanInfo } from 'framer-motion';
import { useCart } from '@shopify/hydrogen-react';
import { ShopifyProductDetailed } from '@/types/shopify';
import Image from 'next/image';

const ArrowLeft = () => ( <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg> );
const ArrowRight = () => ( <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg> );

const getOptimizedShopifyImageUrl = (url: string, size: number) => {
    if (!url) return '';
    try {
        const urlObj = new URL(url);
        const extension = urlObj.pathname.split('.').pop();
        const pathWithoutExtension = urlObj.pathname.substring(0, urlObj.pathname.lastIndexOf('.'));
        return `${urlObj.origin}${pathWithoutExtension}_${size}x.${extension}`;
    } catch (e) { return url; }
};

interface ImmersiveViewProps {
  products: ShopifyProductDetailed[];
  focusedIndex: number;
  setFocusedIndex: (index: number) => void;
}

export const ImmersiveView = ({ products, focusedIndex, setFocusedIndex }: ImmersiveViewProps) => {
    const router = useRouter();
    const { linesAdd, status: cartStatus } = useCart();
    const product = products[focusedIndex];
    const [selectedVariantId, setSelectedVariantId] = useState<string | undefined>();
    const [currentImageIndex, setCurrentImageIndex] = useState(0);
    const [direction, setDirection] = useState(0);

    useEffect(() => {
        const currentProduct = products[focusedIndex];
        if (currentProduct) {
            const firstAvailable = currentProduct.variants.edges.find(v => v.node.availableForSale)?.node;
            setSelectedVariantId(firstAvailable?.id || currentProduct.variants.edges[0]?.node.id);
            setCurrentImageIndex(0);
        }
    }, [focusedIndex, products]);
    
    const selectedVariant = useMemo(() => product?.variants.edges.find(edge => edge.node.id === selectedVariantId)?.node, [product, selectedVariantId]);
    const imageGallery = useMemo(() => {
        if (!product?.featuredImage) return [];
        const otherImages = product.images?.edges.map(edge => edge.node) || [];
        return [product.featuredImage, ...otherImages.filter(img => img.url !== product.featuredImage.url)];
    }, [product]);

    const goToNext = () => { setDirection(1); setFocusedIndex((focusedIndex + 1) % products.length); };
    const goToPrev = () => { setDirection(-1); setFocusedIndex((focusedIndex - 1 + products.length) % products.length); };
    
    const handleDrag = (e: MouseEvent | TouchEvent | PointerEvent, info: PanInfo) => {
        const swipePower = info.offset.x;
        if (swipePower < -100) goToNext();
        else if (swipePower > 100) goToPrev();
    };

    const handleAddToCart = () => { if (selectedVariant) linesAdd([{ merchandiseId: selectedVariant.id, quantity: 1 }]); };
    const isAddingToCart = cartStatus === 'updating';
    
    const cardVariants = {
        enter: (direction: number) => ({ x: direction > 0 ? '100%' : '-100%', opacity: 0 }),
        center: { x: 0, opacity: 1 },
        exit: (direction: number) => ({ x: direction < 0 ? '100%' : '-100%', opacity: 0 }),
    };

    if (!product) return <div className="w-full h-full grid place-items-center text-white/50">Loading...</div>;

    return (
        // --- MARGIN FIX: pt-28 is now applied to ALL screen sizes ---
        <div className="relative w-full flex items-start md:items-center justify-center pt-28 pb-12 px-4">
            
            <button onClick={goToPrev} className="absolute left-2 md:left-8 top-1/2 -translate-y-1/2 z-20 text-white/50 hover:text-white transition-colors p-3"> <ArrowLeft /> </button>
            <button onClick={goToNext} className="absolute right-2 md:right-8 top-1/2 -translate-y-1/2 z-20 text-white/50 hover:text-white transition-colors p-3"> <ArrowRight /> </button>
            
            <div className="relative w-full max-w-5xl h-full">
                <div className="relative w-full h-full overflow-hidden">
                    <AnimatePresence initial={false} custom={direction} mode="wait">
                        <motion.div 
                            key={focusedIndex}
                            custom={direction}
                            variants={cardVariants}
                            initial="enter"
                            animate="center"
                            exit="exit"
                            transition={{ type: 'spring', stiffness: 200, damping: 25 }}
                            drag="x"
                            dragConstraints={{ left: 0, right: 0 }}
                            onDragEnd={handleDrag}
                            // --- MOBILE LAYOUT FIX: The card is now a flex column on mobile ---
                            className="w-full h-auto md:h-[75vh] md:max-h-[650px] rounded-2xl border border-white/10 bg-black/30 backdrop-blur-xl shadow-2xl flex flex-col md:grid md:grid-cols-2 md:grid-rows-1 cursor-grab active:cursor-grabbing"
                        >
                            <div className="w-full aspect-square md:aspect-auto md:h-full relative bg-black/20 flex flex-col p-4">
                                <div className="w-full flex-grow relative">
                                    <AnimatePresence mode="wait">
                                        <motion.div
                                            key={`${focusedIndex}-${currentImageIndex}`}
                                            initial={{ opacity: 0 }}
                                            animate={{ opacity: 1 }}
                                            exit={{ opacity: 0 }}
                                            transition={{ duration: 0.3 }}
                                            className="w-full h-full"
                                        >
                                            <Image
                                                src={getOptimizedShopifyImageUrl(imageGallery[currentImageIndex]?.url, 800)}
                                                alt={imageGallery[currentImageIndex]?.altText || product.title}
                                                fill
                                                className="object-contain rounded-lg pointer-events-none"
                                                style={{ filter: 'drop-shadow(0 10px 15px rgb(0 0 0 / 0.4))' }}
                                                priority={true}
                                                quality={85}
                                                sizes="(max-width: 768px) 100vw, 40vw"
                                            />
                                        </motion.div>
                                    </AnimatePresence>
                                </div>
                                <div className="flex-shrink-0 flex justify-center items-center gap-3 pt-4">
                                    {imageGallery.map((image, index) => (
                                        <button key={`${image?.url}-${index}`} onClick={() => setCurrentImageIndex(index)} className={`w-10 h-14 md:w-12 md:h-16 rounded-md overflow-hidden border-2 transition-colors ${currentImageIndex === index ? 'border-white' : 'border-transparent hover:border-white/50'}`}>
                                            <Image src={getOptimizedShopifyImageUrl(image?.url, 100)} alt={`Thumbnail ${index + 1}`} width={48} height={64} className="object-cover w-full h-full" quality={60} />
                                        </button>
                                    ))}
                                </div>
                            </div>
                            <div className="w-full h-full flex flex-col p-6 md:p-10">
                                <div className="flex flex-col flex-grow min-h-0">
                                    <div>
                                        <h1 className="font-display text-3xl md:text-4xl font-bold">{product.title}</h1>
                                        {selectedVariant && <div className="inline-block mt-3"> <p className="font-mono text-xl text-white/90 bg-white/5 px-3 py-1 rounded-md">${selectedVariant.price.amount}</p> </div> }
                                    </div>
                                    <div className="font-sans text-sm text-white/70 my-4 md:my-6 space-y-4 prose prose-invert max-w-none prose-sm" dangerouslySetInnerHTML={{ __html: product.descriptionHtml }} />
                                    <div className="mt-auto pt-4 md:pt-6 border-t border-white/10">
                                        <div>
                                            <h2 className="font-sans text-xs uppercase tracking-wider text-white/50">Size</h2>
                                            <div className="flex flex-wrap gap-3 mt-3">
    {/* --- THIS IS THE SIZES FIX --- */}
    {/* The `?.` prevents the code from crashing if a product has no variants */}
    {product.variants?.edges.map(({ node: variant }) => (
        <button key={variant.id} onClick={() => setSelectedVariantId(variant.id)} disabled={!variant.availableForSale} className={`px-3 py-1.5 rounded-md font-sans text-xs font-semibold border transition-colors duration-200 ${selectedVariantId === variant.id ? 'bg-white text-black border-white' : 'bg-transparent text-white border-white/20'} ${!variant.availableForSale ? 'opacity-30 cursor-not-allowed line-through' : 'hover:border-white/70'}`} >
            {variant.title}
        </button>
    ))}
</div>
                                        </div>
                                        <button onClick={handleAddToCart} disabled={!selectedVariant?.availableForSale || isAddingToCart} className="w-full mt-6 py-3 bg-white text-black font-sans font-bold uppercase tracking-widest disabled:opacity-50 enabled:hover:bg-white/80 transition-all rounded-full">
                                            {isAddingToCart ? 'Processing...' : !selectedVariant?.availableForSale ? 'Sold Out' : 'Add to Cart'}
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </motion.div>
                    </AnimatePresence>
                </div>
            </div>
        </div>
    );
};

### .\src\components\modules\catalog\ProductMonolith.tsx ###

// src/components/modules/catalog/ProductMonolith.tsx

"use client";

import Link from 'next/link';
import Image from 'next/image';
import { motion, useTransform, MotionValue } from 'framer-motion';
import { ShopifyProduct } from '@/types/shopify';

// Assuming GlitchCanvas is a placeholder for a visual effect. 
// A simple div will suffice for now to show/hide the effect.
const GlitchOverlay = () => (
    <div className="absolute inset-0 bg-black/50" />
);

interface ProductMonolithProps {
  product: ShopifyProduct;
  scrollX: MotionValue<number>;
  index: number;
}

const ITEM_WIDTH = 320; // w-80 from Tailwind
const GAP_WIDTH = 96; // gap-24 from Tailwind
const TOTAL_ITEM_WIDTH = ITEM_WIDTH + GAP_WIDTH;

export const ProductMonolith = ({ product, scrollX, index }: ProductMonolithProps) => {
  const inputRange = [
    (index - 1) * TOTAL_ITEM_WIDTH,
    index * TOTAL_ITEM_WIDTH,
    (index + 1) * TOTAL_ITEM_WIDTH,
  ];

  const focus = useTransform(scrollX, inputRange, [-1, 0, 1]);
  const scale = useTransform(focus, [-1, 0, 1], [0.85, 1, 0.85]);
  const imageOpacity = useTransform(focus, [-0.5, 0, 0.5], [0.3, 1, 0.3]);
  const glitchOpacity = useTransform(focus, [-0.6, 0, 0.6], [1, 0, 1]);
  const pointerEvents = useTransform(focus, (v) => (Math.abs(v) < 0.3 ? 'auto' : 'none'));

  const titleChars = product.title.split('');

  return (
    <Link href={`/products/${product.handle}`} scroll={false}>
      <motion.div
        style={{ scale, pointerEvents }}
        className="relative w-80 h-[480px] rounded-md flex-shrink-0 flex items-center justify-center snap-center"
      >
        {/* Layer 1: The Product Image */}
        {product.featuredImage && (
          <motion.div style={{ opacity: imageOpacity }} className="w-full h-full">
            <Image
              src={product.featuredImage.url}
              alt={product.title}
              width={product.featuredImage.width}
              height={product.featuredImage.height}
              className="w-full h-full object-cover rounded-md"
              priority={index < 3}
            />
          </motion.div>
        )}
        
        {/* Layer 2: The Glitch Overlay */}
        <motion.div 
            className="absolute inset-0 w-full h-full overflow-hidden rounded-md"
            style={{ opacity: glitchOpacity }}
        >
            <GlitchOverlay />
        </motion.div>

        {/* Layer 3: The Deconstructing Title */}
        <h3 className="absolute bottom-8 font-display text-4xl font-bold text-white z-20 pointer-events-none">
          {titleChars.map((char, i) => {
            const y = useTransform(focus, [-1, 0, 1], [(i - titleChars.length/2) * 20, 0, (i - titleChars.length/2) * -20]);
            const rotate = useTransform(focus, [-1, 0, 1], [-20, 0, 20]);
            const charOpacity = useTransform(focus, [-0.6, 0, 0.6], [0, 1, 0]);
            return (
              <motion.span key={i} className="inline-block" style={{ y, rotate, opacity: charOpacity }}>
                {char === ' ' ? '\u00A0' : char}
              </motion.span>
            );
          })}
        </h3>
      </motion.div>
    </Link>
  );
};

### .\src\components\modules\catalog\Viewfinder.tsx ###

// src/components/modules/catalog/Viewfinder.tsx

"use client";

import { useRef, useEffect, useState } from 'react';
import { motion, useScroll, useMotionValueEvent } from 'framer-motion';
import { ShopifyProduct } from '@/types/shopify';
import { ProductMonolith } from './ProductMonolith';

interface ViewfinderProps {
  products: ShopifyProduct[];
  onFocusChange: (intensity: number) => void;
}

const ITEM_WIDTH = 320;
const GAP_WIDTH = 96;
const TOTAL_ITEM_WIDTH = ITEM_WIDTH + GAP_WIDTH;

export const Viewfinder = ({ products, onFocusChange }: ViewfinderProps) => {
  const trackRef = useRef<HTMLDivElement>(null);
  const { scrollX } = useScroll({ container: trackRef });
  const [viewportCenter, setViewportCenter] = useState(0);

  useEffect(() => {
    const updateCenter = () => setViewportCenter(window.innerWidth / 2);
    updateCenter();
    window.addEventListener('resize', updateCenter);
    return () => window.removeEventListener('resize', updateCenter);
  }, []);

  useMotionValueEvent(scrollX, "change", (latestScrollX) => {
    const centerIndex = Math.round(latestScrollX / TOTAL_ITEM_WIDTH);
    const centerOfClosestItem = centerIndex * TOTAL_ITEM_WIDTH + (ITEM_WIDTH / 2);
    const currentCenterOfViewport = latestScrollX + viewportCenter;
    
    const distance = Math.abs(currentCenterOfViewport - centerOfClosestItem);
    const intensity = Math.min(1, distance / (TOTAL_ITEM_WIDTH / 2));
    onFocusChange(intensity);
  });

  return (
    <motion.div
      ref={trackRef}
      className="absolute inset-0 flex overflow-x-scroll snap-x snap-mandatory hide-scrollbar cursor-grab active:cursor-grabbing"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
    >
      <div 
        className="flex items-center gap-24 h-full"
        style={{ 
          paddingLeft: `calc(50vw - ${ITEM_WIDTH / 2}px)`, 
          paddingRight: `calc(50vw - ${ITEM_WIDTH / 2}px)` 
        }}
      >
        {products.map((product, i) => (
          <ProductMonolith
            key={product.id}
            product={product}
            index={i}
            scrollX={scrollX}
          />
        ))}
      </div>
    </motion.div>
  );
};

// A helper style to hide the scrollbar across browsers
const scrollbarHideStyle = `
  .hide-scrollbar {
    -ms-overflow-style: none;  /* IE and Edge */
    scrollbar-width: none;  /* Firefox */
  }
  .hide-scrollbar::-webkit-scrollbar {
    display: none; /* Chrome, Safari and Opera */
  }
`;

if (typeof document !== 'undefined') {
  const styleSheet = document.createElement("style");
  styleSheet.type = "text/css";
  styleSheet.innerText = scrollbarHideStyle;
  document.head.appendChild(styleSheet);
}

### .\src\components\modules\glitch\GlitchCanvas.tsx ###

"use client";
import * as THREE from 'three';
import { Canvas, useFrame, useThree } from '@react-three/fiber';
import { useMemo } from 'react';

const vertexShader = `
  varying vec2 vUv;
  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;

const fragmentShader = `
  varying vec2 vUv;
  uniform float u_time;
  uniform vec2 u_mouse;
  uniform sampler2D u_last_frame;

  float rand(vec2 n) { 
    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
  }

  void main() {
    vec4 lastFrameColor = texture2D(u_last_frame, vUv) * 0.95;
    float dist = distance(vUv, u_mouse);
    float brush = smoothstep(0.1, 0.0, dist);
    float r = rand(vUv + u_time);
    vec2 offset = vec2(r * 0.05, 0.0) * brush;
    vec4 glitchColor = texture2D(u_last_frame, vUv + offset);
    gl_FragColor = max(lastFrameColor, glitchColor * brush);
  }
`;

function Scene() {
  const { size, viewport, gl, camera, clock, pointer } = useThree();
  
  const material = useMemo(() => new THREE.ShaderMaterial({
    uniforms: {
      u_time: { value: 0 },
      u_mouse: { value: new THREE.Vector2(0.5, 0.5) },
      u_last_frame: { value: new THREE.Texture() },
    },
    vertexShader,
    fragmentShader,
  }), []);

  const fbo1 = useMemo(() => new THREE.WebGLRenderTarget(size.width, size.height), [size]);
  const fbo2 = useMemo(() => new THREE.WebGLRenderTarget(size.width, size.height), [size]);
  const quad = useMemo(() => new THREE.Mesh(new THREE.PlaneGeometry(viewport.width, viewport.height), material), [viewport, material]);

  useFrame(() => {
    material.uniforms.u_time.value = clock.getElapsedTime();
    
    // THIS IS THE CORRECT MOUSE TRACKING LOGIC
    material.uniforms.u_mouse.value.lerp(new THREE.Vector2(
      (pointer.x + 1) / 2,
      1.0 - (pointer.y + 1) / 2 // The Y-axis is now correctly inverted
    ), 0.1);

    material.uniforms.u_last_frame.value = fbo1.texture;
    
    gl.setRenderTarget(fbo2);
    gl.render(quad, camera);
    
    gl.setRenderTarget(null);
    gl.render(quad, camera);

    const temp = fbo1;
    fbo1.copy(fbo2);
  });
  
  return <primitive object={quad} />;
}

export const GlitchCanvas = () => {
  return (
    <div className="absolute inset-0 z-20 mix-blend-screen pointer-events-none">
      <Canvas camera={{ position: [0, 0, 1] }}>
        <Scene />
      </Canvas>
    </div>
  );
};

### .\src\components\modules\homepage\BrandManifesto.tsx ###

"use client";
import { motion } from 'framer-motion';

const text = "We are not for everyone. SWAMBASIC is a rejection of the ordinary, a uniform for the discerning individual who moves between worlds. This is luxury defined not by a price tag, but by a perspective.";

export const BrandManifesto = () => {
  return (
    <section className="py-12 px-6 md:px-12 bg-black flex justify-center">
      <motion.div 
        className="max-w-3xl text-center"
        initial="hidden"
        whileInView="visible"
        viewport={{ once: true, amount: 0.5 }}
        transition={{ staggerChildren: 0.05 }}
      >
        <h2 className="font-display font-bold text-4xl md:text-6xl mb-8">
          <motion.span variants={{ hidden: { opacity: 0, y: 20 }, visible: { opacity: 1, y: 0, transition: { duration: 0.8 } } }}>
            The Philosophy
          </motion.span>
        </h2>
        <p className="font-sans text-base md:text-xl leading-relaxed text-white/70">
          {text.split(' ').map((word, i) => (
            <motion.span
              key={i}
              className="inline-block"
              variants={{
                hidden: { opacity: 0 },
                visible: { opacity: 1 }
              }}
              transition={{ duration: 0.5 }}
            >
              {word}Â 
            </motion.span>
          ))}
        </p>
      </motion.div>
    </section>
  );
};

### .\src\components\modules\homepage\FeaturedProducts.tsx ###

// src/components/modules/homepage/FeaturedProducts.tsx

"use client";

import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { ProductCard } from '@/components/modules/products/ProductCard'; 
import { getProducts } from '@/lib/shopify';
import { ShopifyProduct } from '@/types/shopify';

export const FeaturedProducts = () => {
  const [products, setProducts] = useState<ShopifyProduct[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [activeIndex, setActiveIndex] = useState(0);
  const [isHovered, setIsHovered] = useState(false);

  useEffect(() => {
    const fetchProducts = async () => {
      try {
        const fetchedProducts = await getProducts(6); // Get more products for rotation
        setProducts(fetchedProducts);
      } catch (error) { 
        console.error("Failed to fetch products:", error); 
      } finally { 
        setIsLoading(false); 
      }
    };
    fetchProducts();
  }, []);

  // Auto-rotate products
  useEffect(() => {
    if (!isHovered && products.length > 3) {
      const interval = setInterval(() => {
        setActiveIndex((prev) => (prev + 1) % (products.length - 2));
      }, 4000);
      return () => clearInterval(interval);
    }
  }, [products.length, isHovered]);

  if (isLoading) {
    return (
      <section className="py-24 px-6 md:px-12 bg-black text-center overflow-hidden">
        <div className="relative">
          <motion.div
            className="absolute inset-0 bg-gradient-to-r from-transparent via-white/5 to-transparent"
            animate={{ x: [-1000, 1000] }}
            transition={{ duration: 2, repeat: Infinity, ease: "linear" }}
          />
          <h2 className="font-display text-4xl mb-12 text-white relative z-10">Featured Collection</h2>
          <div className="flex justify-center items-center space-x-2">
            {[0, 1, 2].map((i) => (
              <motion.div
                key={i}
                className="w-2 h-2 bg-white/30 rounded-full"
                animate={{ scale: [1, 1.5, 1], opacity: [0.3, 1, 0.3] }}
                transition={{ duration: 1.5, delay: i * 0.2, repeat: Infinity }}
              />
            ))}
          </div>
        </div>
      </section>
    );
  }

  const displayProducts = products.slice(activeIndex, activeIndex + 3);

  return (
    <section className="py-24 px-6 md:px-12 bg-black relative overflow-hidden">
      {/* Animated background elements */}
      <div className="absolute inset-0 opacity-10">
        <motion.div
          className="absolute top-20 left-10 w-32 h-32 border border-white/20 rounded-full"
          animate={{ 
            rotate: 360,
            scale: [1, 1.2, 1],
          }}
          transition={{ 
            rotate: { duration: 20, repeat: Infinity, ease: "linear" },
            scale: { duration: 8, repeat: Infinity, ease: "easeInOut" }
          }}
        />
        <motion.div
          className="absolute bottom-20 right-10 w-24 h-24 bg-white/5 rounded-full"
          animate={{ 
            y: [-20, 20, -20],
            opacity: [0.5, 1, 0.5]
          }}
          transition={{ duration: 6, repeat: Infinity, ease: "easeInOut" }}
        />
        <motion.div
          className="absolute top-1/2 left-1/4 w-1 h-20 bg-gradient-to-b from-transparent via-white/20 to-transparent"
          animate={{ scaleY: [0, 1, 0] }}
          transition={{ duration: 3, repeat: Infinity, ease: "easeInOut" }}
        />
      </div>

      <div className="relative z-10">
        <motion.div
          className="text-center mb-16"
          initial={{ opacity: 0 }}
          whileInView={{ opacity: 1 }}
          viewport={{ once: true }}
        >
          <motion.h2 
            className="font-display text-4xl md:text-5xl mb-4 text-white"
            initial={{ opacity: 0, y: 30 }}
            whileInView={{ opacity: 1, y: 0 }}
            viewport={{ once: true }}
            transition={{ duration: 1 }}
          >
            Featured Collection
          </motion.h2>
          <motion.div
            className="w-20 h-0.5 bg-gradient-to-r from-transparent via-white to-transparent mx-auto"
            initial={{ scaleX: 0 }}
            whileInView={{ scaleX: 1 }}
            viewport={{ once: true }}
            transition={{ duration: 1.5, delay: 0.5 }}
          />
        </motion.div>

        {/* Dynamic product showcase */}
        <div 
          className="max-w-6xl mx-auto"
          onMouseEnter={() => setIsHovered(true)}
          onMouseLeave={() => setIsHovered(false)}
        >
          <AnimatePresence mode="wait">
            <motion.div
              key={activeIndex}
              className="grid md:grid-cols-3 gap-8"
              initial={{ opacity: 0, y: 50 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -50 }}
              transition={{ duration: 0.8, staggerChildren: 0.2 }}
            >
              {displayProducts.map((product, index) => (
                <motion.div
                  key={`${activeIndex}-${index}`}
                  className="relative group"
                  initial={{ opacity: 0, y: 60, rotateX: -15 }}
                  animate={{ opacity: 1, y: 0, rotateX: 0 }}
                  transition={{ 
                    duration: 0.8, 
                    delay: index * 0.2,
                    type: "spring",
                    stiffness: 100
                  }}
                  whileHover={{ 
                    y: -10, 
                    scale: 1.02,
                    transition: { duration: 0.3 }
                  }}
                >
                  {/* Glowing border effect */}
                  <motion.div
                    className="absolute -inset-0.5 bg-gradient-to-r from-white/20 via-white/5 to-white/20 rounded-lg opacity-0 group-hover:opacity-100 blur-sm"
                    initial={false}
                    animate={{ opacity: 0 }}
                    whileHover={{ opacity: 1 }}
                    transition={{ duration: 0.3 }}
                  />
                  
                  {/* Product card with enhanced styling */}
                  <div className="relative bg-zinc-900/50 backdrop-blur-sm rounded-lg overflow-hidden border border-white/10 group-hover:border-white/20 transition-all duration-300">
                    <ProductCard product={product} />
                  </div>

                  {/* Floating accent */}
                  <motion.div
                    className="absolute -top-2 -right-2 w-4 h-4 bg-white/20 rounded-full opacity-0 group-hover:opacity-100"
                    animate={{ 
                      scale: [1, 1.5, 1],
                      opacity: [0.5, 1, 0.5]
                    }}
                    transition={{ 
                      duration: 2, 
                      repeat: Infinity,
                      ease: "easeInOut"
                    }}
                  />
                </motion.div>
              ))}
            </motion.div>
          </AnimatePresence>

          {/* Navigation dots */}
          {products.length > 3 && (
            <motion.div 
              className="flex justify-center mt-12 space-x-3"
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ delay: 1 }}
            >
              {Array.from({ length: products.length - 2 }).map((_, index) => (
                <motion.button
                  key={index}
                  className={`w-2 h-2 rounded-full transition-all duration-300 ${
                    index === activeIndex 
                      ? 'bg-white w-8' 
                      : 'bg-white/30 hover:bg-white/50'
                  }`}
                  onClick={() => setActiveIndex(index)}
                  whileHover={{ scale: 1.2 }}
                  whileTap={{ scale: 0.9 }}
                />
              ))}
            </motion.div>
          )}
        </div>

        {/* Call to action */}
        <motion.div
          className="text-center mt-16"
          initial={{ opacity: 0, y: 30 }}
          whileInView={{ opacity: 1, y: 0 }}
          viewport={{ once: true }}
          transition={{ duration: 1, delay: 0.5 }}
        >
          <motion.button
            className="group relative px-8 py-3 bg-transparent border border-white/20 text-white font-medium rounded-full overflow-hidden hover:border-white/40 transition-all duration-300"
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
          >
            <motion.div
              className="absolute inset-0 bg-white/5 translate-x-full group-hover:translate-x-0 transition-transform duration-300"
            />
            <span 
              className="relative z-10 cursor-pointer"
              onClick={() => window.location.href = "/catalog"}
            >
              View All Products
            </span>
          </motion.button>
        </motion.div>
      </div>
    </section>
  );
};

### .\src\components\modules\homepage\GlitchMarquee.tsx ###

"use client";

import React, { useState, useEffect, useRef } from 'react';

interface TerminalEntry {
  type: 'command' | 'output' | 'easter' | 'secret';
  text: string;
}

const TerminalFooter = () => {
  const [currentLine, setCurrentLine] = useState(0);
  const [displayText, setDisplayText] = useState('');
  const [isTyping, setIsTyping] = useState(false);
  const [showCursor, setShowCursor] = useState(true);
  const [terminalHistory, setTerminalHistory] = useState<TerminalEntry[]>([]);
  const [isHovered, setIsHovered] = useState(false);
  const [clickCount, setClickCount] = useState(0);
  const [isMounted, setIsMounted] = useState(false);
  const containerRef = useRef<HTMLElement>(null);

  // --- THIS IS THE FIX: The command list is now longer and more varied ---
  const commands = [
    { command: "> initiate --protocol=swambasic", output: "protocol loaded. welcome.", delay: 2000 },
    { command: "> cat /etc/philosophy", output: "form. function. perspective.", delay: 2500 },
    { command: "> query --identity", output: "we are not for everyone. and we never will be.", delay: 3000 },
    { command: "> get_var --collection", output: "vol. 1 // sins of saints", delay: 2800 },
    { command: "> social --connect --platform=instagram", output: "now streaming consciousness: @swambasic", delay: 3200 },
    { command: "> echo 'the concept'", output: "luxury is a mindset, not a price tag.", delay: 3000 },
    { command: "> run diagnostic --aesthetic", output: "result: [OK] minimal. textural. intentional.", delay: 2800 },
    { command: "> read /dev/thoughts --filter=genz", output: "iykyk. the vibe is the brand.", delay: 2500 },
    { command: "> get_directive --current", output: "reject the ordinary.", delay: 3000 },
    { command: "> stream --updates", output: "new artifacts are being forged in the void...", delay: 3500 },
    { command: "> cat /logs/saints.log", output: "ERROR: no saints found.", delay: 2800 },
    { command: "> cat /logs/sins.log", output: "log file too large to display.", delay: 2800 },
    { command: "> follow --us", output: "find us in the static: @swambasic", delay: 3200 },
    { command: "> exit --code=0", output: "disconnecting... but the signal remains.", delay: 3000 }
  ];

  const easterEggs = [
    "> this is not a footer.",
    "> where does the minimalism end?",
    "> ask a better question.",
    "> find what you are not looking for.",
    "> iykyk"
  ];

  const secrets = [
    "// form is an illusion.",
    "/* function is a construct. */", 
    "// perspective is the only constant.",
    "/* the void is staring back. */",
    "// did you see it?"
  ];
  // --- END OF THE FIX ---

  useEffect(() => {
    setIsMounted(true);
  }, []);

  useEffect(() => {
    const typeCommand = async (text: string, isCommand = true) => {
      setIsTyping(true);
      setDisplayText('');
      for (let i = 0; i <= text.length; i++) {
        setDisplayText(text.slice(0, i));
        await new Promise(resolve => setTimeout(resolve, isCommand ? 40 : 25));
      }
      setIsTyping(false);
      return new Promise(resolve => setTimeout(resolve, 800));
    };

    const runCommand = async () => {
      const cmd = commands[currentLine];
      await typeCommand(cmd.command, true);
      setTerminalHistory(prev => [...prev, { type: 'command', text: cmd.command }]);
      await new Promise(resolve => setTimeout(resolve, 200));
      await typeCommand(cmd.output, false);
      setTerminalHistory(prev => [...prev, { type: 'output', text: cmd.output }]);
      await new Promise(resolve => setTimeout(resolve, cmd.delay));
      setCurrentLine(prev => (prev + 1) % commands.length);
    };

    const interval = setTimeout(runCommand, 1000);
    return () => clearTimeout(interval);
  }, [currentLine, commands]);

  useEffect(() => {
    const cursorInterval = setInterval(() => {
      setShowCursor(prev => !prev);
    }, 500);
    return () => clearInterval(cursorInterval);
  }, []);

  const handleClick = () => {
    setClickCount(prev => prev + 1);
    const randomEgg = easterEggs[Math.floor(Math.random() * easterEggs.length)];
    const randomSecret = secrets[Math.floor(Math.random() * secrets.length)];
    if (clickCount % 3 === 2) {
      setTerminalHistory(prev => [...prev, { type: 'secret', text: randomSecret }]);
    } else {
      setTerminalHistory(prev => [...prev, { type: 'easter', text: randomEgg }]);
    }
  };

  const formatTime = () => {
    if (!isMounted) return "00:00:00";
    const now = new Date();
    return now.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
  };

  return (
    <footer 
      ref={containerRef}
      className="bg-black text-green-400 font-mono text-sm relative border-t border-green-900/50 cursor-pointer overflow-hidden"
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
      onClick={handleClick}
    >
      <div className="absolute inset-0 pointer-events-none">
        <div className="absolute inset-0 bg-gradient-to-b from-transparent via-green-400/5 to-transparent animate-pulse"></div>
        <div className="absolute inset-0 bg-[linear-gradient(transparent_98%,rgba(34,197,94,0.1)_100%)] bg-[length:100%_4px]"></div>
      </div>
      <div className={`absolute inset-0 transition-opacity duration-1000 ${isHovered ? 'bg-green-400/5' : 'bg-green-400/2'}`}></div>
      <div className="relative z-10 p-6 max-w-6xl mx-auto">
        <div className="flex items-center justify-between mb-4 text-xs text-green-500/70">
          <div className="flex items-center space-x-4">
            <div className="flex space-x-2">
              <div className="w-3 h-3 rounded-full bg-red-500/60"></div>
              <div className="w-3 h-3 rounded-full bg-yellow-500/60"></div>
              <div className="w-3 h-3 rounded-full bg-green-500/60"></div>
            </div>
            <span>swambasic_consciousness_interface</span>
          </div>
          <div className="flex items-center space-x-4">
            <span>{formatTime()}</span>
            <span className={`transition-opacity ${isHovered ? 'opacity-100' : 'opacity-50'}`}>â—‰ STREAMING</span>
          </div>
        </div>
        <div className="space-y-1 min-h-[200px] max-h-[300px] overflow-y-auto">
          {terminalHistory.slice(-10).map((entry, index) => (
            <div key={index} className={`transition-all duration-300 ${ entry.type === 'command' ? 'text-green-400' : entry.type === 'output' ? 'text-green-300/80 ml-2' : entry.type === 'easter' ? 'text-cyan-400' : 'text-gray-500 italic' }`}>
              {entry.text}
            </div>
          ))}
          <div className="flex items-center">
            <span className="text-green-400">{displayText}</span>
            <span className={`ml-1 ${showCursor && !isTyping ? 'opacity-100' : 'opacity-0'} transition-opacity`}>â–ˆ</span>
          </div>
        </div>
        <div className="mt-6 pt-4 border-t border-green-900/30 flex justify-between items-center text-xs text-green-600/60">
          <div className="flex space-x-6">
            <span>form</span>
            <span>//</span>
            <span>function</span>
            <span>//</span>
            <span>perspective</span>
            <span>â€¢</span>
            <span className={isHovered ? 'text-green-400' : ''}> [interact] </span>
          </div>
          <div className="text-green-500/40">
            {clickCount > 0 && `log: ${clickCount} thoughts processed`}
          </div>
        </div>
      </div>
      <div className="absolute inset-0 pointer-events-none">
        <div className="absolute top-0 left-0 w-full h-px bg-gradient-to-r from-transparent via-green-400/50 to-transparent animate-pulse"></div>
      </div>
      <style jsx>{`
        .space-y-1::-webkit-scrollbar { width: 6px; }
        .space-y-1::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.3); }
        .space-y-1::-webkit-scrollbar-thumb { background: rgba(34, 197, 94, 0.3); border-radius: 3px; }
      `}</style>
    </footer>
  );
};

export default TerminalFooter;

### .\src\components\modules\homepage\HeroSection.tsx ###

// src/components/modules/homepage/HeroSection.tsx

"use client";
import Link from 'next/link';
import { motion } from 'framer-motion';

export const HeroSection = () => {
  return (
    <section className="relative h-screen w-screen flex items-center justify-center">
      <video src="/hero-video.mp4" autoPlay loop muted playsInline className="absolute top-0 left-0 w-full h-full object-cover -z-10" />
      <div className="absolute top-0 left-0 w-full h-full bg-black/50 -z-10" />
      <motion.div 
        className="text-center text-white z-10 flex flex-col items-center" // --- FIX: Added flexbox for alignment
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 1, delay: 0.5 }}
      >
        <h1 className="font-display font-black text-5xl md:text-8xl uppercase">
          First Drop Is Live
        </h1>
        {/* --- FIX: max-w-lg ensures this text wraps correctly relative to the heading --- */}
        <p className="font-sans text-center mt-4 max-w-lg">
          Explore the inaugural collection. Limited quantities available.
        </p>
        <Link href="/catalog" passHref>
          <motion.button 
            className="mt-8 px-8 py-4 bg-white/90 text-black font-sans font-bold uppercase tracking-widest rounded-full"
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
          >
            Shop Now
          </motion.button>
        </Link>
      </motion.div>
    </section>
  );
};

### .\src\components\modules\homepage\InteractiveMarquee.tsx ###

// src/components/modules/homepage/InteractiveMarquee.tsx
"use client";
import { useRef } from 'react';
import { motion, useScroll, useTransform } from 'framer-motion';

const MarqueeText = ({ children, speed }: { children: React.ReactNode, speed: number }) => {
    return (
        <div className="flex" style={{ transform: `translateX(${speed}%)` }}>
            <span className="font-display text-6xl md:text-8xl text-stroke whitespace-nowrap pr-16">{children}</span>
            <span className="font-display text-6xl md:text-8xl text-stroke whitespace-nowrap pr-16">{children}</span>
        </div>
    );
}

export const InteractiveMarquee = () => {
    const marqueeRef = useRef(null);
    const { scrollYProgress } = useScroll({
        target: marqueeRef,
        offset: ['start end', 'end start']
    });

    // This transforms the scroll progress (0 to 1) into a motion value
    const speed = useTransform(scrollYProgress, [0, 1], [-20, 0]);

    return (
        <section ref={marqueeRef} className="py-16 md:py-24 bg-black overflow-hidden">
            <MarqueeText speed={speed.get()}>
                Form Â Â Â  Function Â Â Â  Perspective Â Â Â 
            </MarqueeText>
        </section>
    );
};

### .\src\components\modules\products\InteractiveProductCard.tsx ###

// src/components/modules/products/InteractiveProductCard.tsx

"use client";

import { useState, useMemo } from 'react';
import { useRouter } from 'next/navigation';
import { motion, AnimatePresence } from 'framer-motion';
import { useCart } from '@shopify/hydrogen-react';
import { ShopifyProductDetailed } from '@/types/shopify';
import { useMediaQuery } from '@/hooks/useMediaQuery';
import { useCartNotification } from '@/hooks/useCartNotification';
import Image from 'next/image';

const getOptimizedShopifyImageUrl = (url: string, size: number) => {
    if (!url) return '';
    try {
        const urlObj = new URL(url);
        const extension = urlObj.pathname.split('.').pop();
        const pathWithoutExtension = urlObj.pathname.substring(0, urlObj.pathname.lastIndexOf('.'));
        return `${urlObj.origin}${pathWithoutExtension}_${size}x.${extension}`;
    } catch (e) { return url; }
};

const ArrowLeft = () => ( <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg> );
const ArrowRight = () => ( <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg> );

interface InteractiveProductCardProps {
  product: ShopifyProductDetailed;
}

export const InteractiveProductCard = ({ product }: InteractiveProductCardProps) => {
    const router = useRouter();
    const { linesAdd, status: cartStatus } = useCart();
    const { showNotification } = useCartNotification();
    const [isUIActive, setUIActive] = useState(false);
    const isHoverCapable = useMediaQuery('(hover: hover)');
    const [currentImageIndex, setCurrentImageIndex] = useState(0);
    const [selectedVariantId, setSelectedVariantId] = useState<string | undefined>(
        product.variants.edges.find(v => v.node.availableForSale)?.node.id || product.variants.edges[0]?.node.id
    );

    const imageGallery = useMemo(() => {
        if (!product?.featuredImage) return [];
        const otherImages = product.images?.edges.map(edge => edge.node) || [];
        return [product.featuredImage, ...otherImages.filter(img => img.url !== product.featuredImage.url)];
    }, [product]);

    const handleNextImage = (e: React.MouseEvent) => { e.stopPropagation(); setCurrentImageIndex((p) => (p + 1) % imageGallery.length); };
    const handlePrevImage = (e: React.MouseEvent) => { e.stopPropagation(); setCurrentImageIndex((p) => (p - 1 + imageGallery.length) % imageGallery.length); };

    const handleAddToCart = (e: React.MouseEvent) => {
        e.stopPropagation();
        const selectedVariant = product.variants.edges.find(edge => edge.node.id === selectedVariantId)?.node;
        if (selectedVariant) {
            linesAdd([{ merchandiseId: selectedVariant.id, quantity: 1 }]);
            showNotification(`${product.title} added to cart`);
        }
    };
    
    const isAddingToCart = cartStatus === 'updating';

    const handleCardClick = () => {
        if (!isHoverCapable) {
            setUIActive(!isUIActive);
        } else {
            router.push(`/products/${product.handle}`);
        }
    };

    return (
        <motion.div 
            className="group relative w-full cursor-pointer"
            onClick={handleCardClick}
            onHoverStart={() => isHoverCapable && setUIActive(true)}
            onHoverEnd={() => isHoverCapable && setUIActive(false)}
        >
            <div className="relative w-full rounded-xl border border-white/10 bg-black/20 backdrop-blur-xl shadow-lg overflow-hidden transition-shadow duration-300 group-hover:shadow-black/50">
                <div className="relative w-full aspect-[3/4] bg-black/20">
                    <AnimatePresence mode="wait">
                        {/* --- THIS IS THE FIX: A new, more subtle animation --- */}
                        <motion.div
                            key={currentImageIndex}
                            initial={{ opacity: 0, scale: 0.98 }}
                            animate={{ opacity: 1, scale: 1 }}
                            exit={{ opacity: 0, scale: 0.98 }}
                            transition={{ duration: 0.4, ease: [0.4, 0, 0.2, 1] }}
                            className="w-full h-full"
                        >
                            <Image
                                src={getOptimizedShopifyImageUrl(imageGallery[currentImageIndex]?.url, 600)}
                                alt={imageGallery[currentImageIndex]?.altText || product.title}
                                fill
                                className="object-cover"
                                quality={80}
                                sizes="(max-width: 768px) 50vw, 25vw"
                            />
                        </motion.div>
                    </AnimatePresence>
                    
                    <AnimatePresence>
                        {isUIActive && (
                            <>
                                <motion.button onClick={handlePrevImage} className="absolute top-1/2 left-2 -translate-y-1/2 z-10 p-2 rounded-full bg-black/40 text-white/70 hover:text-white backdrop-blur-sm" initial={{ opacity: 0, x: -10 }} animate={{ opacity: 1, x: 0 }} exit={{ opacity: 0, x: -10 }} transition={{ duration: 0.2 }}> <ArrowLeft /> </motion.button>
                                <motion.button onClick={handleNextImage} className="absolute top-1/2 right-2 -translate-y-1/2 z-10 p-2 rounded-full bg-black/40 text-white/70 hover:text-white backdrop-blur-sm" initial={{ opacity: 0, x: 10 }} animate={{ opacity: 1, x: 0 }} exit={{ opacity: 0, x: 10 }} transition={{ duration: 0.2 }}> <ArrowRight /> </motion.button>
                            </>
                        )}
                    </AnimatePresence>
                </div>

                <div className="p-4">
                    <h3 className="font-sans font-semibold text-white truncate">{product.title}</h3>
                    <p className="font-mono text-sm text-white/70">${product.priceRange.minVariantPrice.amount}</p>
                </div>

                <AnimatePresence>
                    {isUIActive && (
                        <motion.div 
                            className="absolute bottom-0 left-0 w-full p-4 bg-gradient-to-t from-black via-black/90 to-transparent z-20"
                            initial={{ opacity: 0, y: 20 }}
                            animate={{ opacity: 1, y: 0 }}
                            exit={{ opacity: 0, y: 20 }}
                            transition={{ duration: 0.3, ease: 'easeInOut' }}
                        >
                            <div className="flex flex-wrap gap-2 mb-3">
                                {product.variants?.edges.map(({ node: variant }) => (
                                    <button
                                        key={variant.id}
                                        onClick={(e) => { e.stopPropagation(); setSelectedVariantId(variant.id); }}
                                        disabled={!variant.availableForSale}
                                        className={`px-2 py-1 rounded-md font-sans text-[10px] font-semibold border transition-colors duration-200 ${selectedVariantId === variant.id ? 'bg-white text-black border-white' : 'bg-transparent text-white border-white/20'} ${!variant.availableForSale ? 'opacity-30 cursor-not-allowed' : 'hover:border-white/70'}`}
                                    >
                                        {variant.title}
                                    </button>
                                ))}
                            </div>
                            <button
                                onClick={handleAddToCart}
                                disabled={!selectedVariantId || isAddingToCart}
                                className="w-full py-2 bg-white/90 text-black font-sans text-xs font-bold uppercase tracking-widest disabled:opacity-50 enabled:hover:bg-white transition-all rounded-full"
                            >
                                {isAddingToCart ? '...' : 'Quick Add'}
                            </button>
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>
        </motion.div>
    );
};

### .\src\components\modules\products\ProductCard.tsx ###

// src/components/modules/products/ProductCard.tsx

"use client";
import Link from 'next/link';
import Image from 'next/image';
import { motion } from 'framer-motion';
import { ShopifyProduct } from '@/types/shopify';

interface ProductCardProps {
  product: ShopifyProduct;
}

export const ProductCard = ({ product }: ProductCardProps) => {
  return (
    <Link href={`/products/${product.handle}`} passHref>
      <motion.div
        className="group" // Add a group class for hover effects
        whileHover={{ y: -5 }}
        transition={{ type: 'spring', stiffness: 300 }}
      >
        <div className="w-full aspect-[3/4] bg-white/5 rounded-lg overflow-hidden relative">
          {product.featuredImage ? (
            <Image
              src={product.featuredImage.url}
              alt={product.featuredImage.altText || product.title}
              width={product.featuredImage.width}
              height={product.featuredImage.height}
              className="w-full h-full object-cover transition-transform duration-500 group-hover:scale-105"
            />
          ) : (
            <div className="w-full h-full flex items-center justify-center">
              <span className="text-sm text-white/50">No Image</span>
            </div>
          )}
        </div>
        <div className="mt-4 text-left">
          <h3 className="font-sans font-semibold text-white">{product.title}</h3>
          <p className="font-mono text-sm text-white/70">${product.priceRange.minVariantPrice.amount}</p>
        </div>
      </motion.div>
    </Link>
  );
};

### .\src\components\modules\products\ProductDetails.tsx ###

// src/components/modules/products/ProductDetails.tsx

"use client";

import { useState, useMemo } from 'react';
import Image from 'next/image';
import { useCart } from '@shopify/hydrogen-react';
import { ShopifyProductDetailed, ShopifyProductVariant } from '@/types/shopify';
import { motion, AnimatePresence } from 'framer-motion';

interface ProductDetailsProps {
  product: ShopifyProductDetailed;
}

export const ProductDetails = ({ product }: ProductDetailsProps) => {
  // Use the useCart hook to get the linesAdd function and cart status
  const { linesAdd, status } = useCart();

  // Find the first available variant to set as the initial state
  const firstAvailableVariant = useMemo(() => 
    product.variants.edges.find(edge => edge.node.availableForSale)?.node || product.variants.edges[0].node,
    [product.variants.edges]
  );
  
  // State to track the ID of the currently selected variant
  const [selectedVariantId, setSelectedVariantId] = useState<string>(firstAvailableVariant.id);

  // Derive the full variant object from the selected ID
  const selectedVariant = useMemo((): ShopifyProductVariant | undefined => {
    return product.variants.edges.find(edge => edge.node.id === selectedVariantId)?.node;
  }, [selectedVariantId, product.variants]);

  // Handle adding the selected variant to the cart
  const handleAddToCart = () => {
    if (!selectedVariant) return;
    linesAdd([{
      merchandiseId: selectedVariant.id,
      quantity: 1,
    }]);
  };

  const isAdding = status === 'updating';


  return (
    <div className="grid grid-cols-1 lg:grid-cols-2 gap-12 lg:gap-16">
      
      {/* Column 1: Image Gallery */}
      <div className="w-full aspect-square bg-white/5 rounded-lg overflow-hidden">
         {product.featuredImage && (
            <Image
              src={product.featuredImage.url}
              alt={product.featuredImage.altText || product.title}
              width={product.featuredImage.width}
              height={product.featuredImage.height}
              className="w-full h-full object-cover"
              priority
            />
          )}
      </div>

      {/* Column 2: Product Information & Actions */}
      <div className="flex flex-col">
        <h1 className="font-display text-4xl md:text-5xl font-bold">{product.title}</h1>
        
        {/* Price display that updates based on the selected variant */}
        <p className="font-mono text-xl text-white/80 my-4">
          ${selectedVariant?.price.amount}
        </p>

        {/* This renders the HTML description from Shopify */}
        <div 
          className="font-sans text-white/70 space-y-4 prose prose-invert max-w-none"
          dangerouslySetInnerHTML={{ __html: product.descriptionHtml }} 
        />
        
        <div className="mt-8 pt-8 border-t border-white/10">
            <h2 className="font-sans text-sm uppercase tracking-wider text-white/50">
              Select Size
            </h2>
            <div className="flex flex-wrap gap-3 mt-4">
              {product.variants.edges.map(({ node: variant }) => (
                <button
                  key={variant.id}
                  onClick={() => setSelectedVariantId(variant.id)}
                  disabled={!variant.availableForSale}
                  className={`px-4 py-2 rounded-md font-sans text-sm font-semibold border transition-colors duration-200
                    ${selectedVariantId === variant.id
                      ? 'bg-white text-black border-white'
                      : 'bg-transparent text-white border-white/20'
                    }
                    ${!variant.availableForSale
                      ? 'opacity-30 cursor-not-allowed line-through'
                      : 'hover:border-white/70'
                    }
                  `}
                >
                  {variant.title}
                </button>
              ))}
            </div>

            <button 
              onClick={handleAddToCart}
              // Disable button if variant isn't available or if adding is in progress
              disabled={!selectedVariant?.availableForSale || isAdding}
              className="w-full mt-8 py-4 bg-white text-black font-sans font-bold uppercase tracking-widest disabled:opacity-50 enabled:hover:bg-white/80 transition-all"
            >
              {isAdding
                ? 'Adding...'
                : !selectedVariant?.availableForSale
                ? 'Sold Out'
                : 'Add to Cart'
              }
            </button>
        </div>

      </div>
    </div>
  );
};

### .\src\hooks\useCartNotification.tsx ###

// src/hooks/useCartNotification.tsx

import { create } from 'zustand';
import { useCart } from '@shopify/hydrogen-react';
import { useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';

interface CartNotificationState {
  isVisible: boolean;
  message: string;
  cartCount: number;
  showNotification: (message: string) => void;
  hideNotification: () => void;
  setCartCount: (count: number) => void;
}

const useCartNotificationStore = create<CartNotificationState>((set) => ({
  isVisible: false,
  message: '',
  cartCount: 0,
  showNotification: (message) => {
    set({ isVisible: true, message });
    setTimeout(() => set({ isVisible: false }), 2000);
  },
  hideNotification: () => set({ isVisible: false }),
  setCartCount: (count) => set({ cartCount: count }),
}));

// This is the UI component for the pop-up
export const CartToast = () => {
    const { isVisible, message } = useCartNotificationStore();
    return (
        <AnimatePresence>
            {isVisible && (
                <motion.div
                    initial={{ opacity: 0, y: 50 }}
                    animate={{ opacity: 1, y: 0 }}
                    exit={{ opacity: 0, y: 20 }}
                    className="fixed bottom-24 left-1/2 -translate-x-1/2 z-50 px-6 py-3 bg-white text-black font-sans font-bold text-sm rounded-full shadow-lg"
                >
                    {message}
                </motion.div>
            )}
        </AnimatePresence>
    );
};

// This is the hook we will use in other components
export const useCartNotification = () => {
    const { showNotification, setCartCount, cartCount } = useCartNotificationStore();
    const { totalQuantity } = useCart();

    useEffect(() => {
        setCartCount(totalQuantity ?? 0);
    }, [totalQuantity, setCartCount]);
    
    return { showNotification, cartCount };
};

### .\src\hooks\useGyroscope.ts ###

// src/hooks/useGyroscope.ts
"use client";
import { useState, useEffect, useCallback } from 'react';
import * as THREE from 'three';

// This hook will manage all gyroscope logic
export const useGyroscope = () => {
    const [needsPermission, setNeedsPermission] = useState(false);
    const [permissionGranted, setPermissionGranted] = useState(false);
    // This state will hold the SMOOTHED gyroscope data
    const [smoothedGyroData, setSmoothedGyroData] = useState({ x: 0, y: 0 });

    useEffect(() => {
        // Check if the permission API exists (for iOS 13+)
        if (typeof (DeviceOrientationEvent as any).requestPermission === 'function') {
            setNeedsPermission(true);
        }

        // This is the function that listens to the device's motion
        const handleDeviceOrientation = (event: DeviceOrientationEvent) => {
            const { beta, gamma } = event; // beta: front-back tilt, gamma: left-right
            if (beta !== null && gamma !== null) {
                // 1. Get the raw sensor data and normalize it
                const rawX = THREE.MathUtils.clamp(gamma / 90, -1, 1);
                const rawY = THREE.MathUtils.clamp(beta / 90, -1, 1);

                // --- THE FIX IS HERE ---
                // 2. Instead of setting the state directly with the raw data,
                // we smoothly interpolate ("lerp") the current value towards the new raw value.
                // This dampens any sudden jumps or "jerks". The `0.1` is the smoothing factor.
                setSmoothedGyroData(currentSmoothedValue => ({
                    x: THREE.MathUtils.lerp(currentSmoothedValue.x, rawX, 0.1),
                    y: THREE.MathUtils.lerp(currentSmoothedValue.y, rawY, 0.1)
                }));
            }
        };

        // We only start listening for motion AFTER permission has been granted
        if (permissionGranted) {
            window.addEventListener('deviceorientation', handleDeviceOrientation);
            return () => {
                window.removeEventListener('deviceorientation', handleDeviceOrientation);
            };
        }
    }, [permissionGranted]); // This effect re-runs if permission is granted

    // The function our button will call to ask for permission
    const requestPermission = useCallback(() => {
        if (typeof (DeviceOrientationEvent as any).requestPermission === 'function') {
            (DeviceOrientationEvent as any).requestPermission()
                .then((permissionState: string) => {
                    if (permissionState === 'granted') {
                        setPermissionGranted(true);
                    }
                })
                .catch(console.error);
        } else {
            // For Android or other devices that don't need a prompt
            setPermissionGranted(true);
        }
    }, []);

    // The hook provides all the necessary tools to the components
    return { needsPermission, requestPermission, smoothedGyroData };
};

### .\src\hooks\useMediaQuery.ts ###

"use client";

import { useState, useEffect } from 'react';

/**
 * A custom hook to track the state of a CSS media query.
 * @param query The media query string to watch (e.g., '(max-width: 767px)').
 * @returns A boolean indicating whether the media query matches.
 */
export const useMediaQuery = (query: string): boolean => {
  // Ensure this runs only on the client
  const [matches, setMatches] = useState<boolean>(
    typeof window !== 'undefined' ? window.matchMedia(query).matches : false
  );

  useEffect(() => {
    const mediaQueryList = window.matchMedia(query);
    const listener = (event: MediaQueryListEvent) => {
      setMatches(event.matches);
    };

    // Use the modern addEventListener/removeEventListener
    mediaQueryList.addEventListener('change', listener);
    
    // Check again on mount in case the initial state was stale
    setMatches(mediaQueryList.matches);

    return () => {
      mediaQueryList.removeEventListener('change', listener);
    };
  }, [query]);

  return matches;
};

### .\src\hooks\useSound.ts ###

"use client";

import { useCallback } from 'react';

/**
 * A custom hook to play a sound effect.
 * @param soundPath The path to the sound file from the `public` directory.
 * @param volume The volume to play the sound at (0.0 to 1.0). Defaults to 0.5.
 * @returns A `play` function to trigger the sound.
 */
export const useSound = (soundPath: string, volume: number = 0.5) => {
  const play = useCallback(() => {
    // We create a new Audio object on each play call.
    // This is simple and effective for short, non-overlapping SFX.
    const audio = new Audio(soundPath);
    audio.volume = volume;
    audio.play().catch(e => {
      // Audio playback can sometimes be blocked by the browser, so we log errors silently.
      console.error(`Could not play sound ${soundPath}:`, e);
    });
  }, [soundPath, volume]);

  return play;
};

### .\src\lib\constants.ts ###

// src/lib/constants.ts

export const SHOPIFY_CUSTOMER_ACCESS_TOKEN_COOKIE = "shopify_customer_access_token";

### .\src\lib\shopify.ts ###

// src/lib/shopify.ts

import { 
  ShopifyProductsResponseBody, 
  ShopifyProduct,
  ShopifyCustomerLoginResponseBody,
  CustomerLoginPayload,
  ShopifyCustomerDataResponseBody,
  ShopifyCustomer,
  ShopifyAddressCreateResponseBody,
  ShopifyCustomerUpdateResponseBody,
  NewAddressInput,
  ShopifyProductDetailed, 
  ShopifyProductDetailedResponseBody
} from '@/types/shopify';

const domain = process.env.NEXT_PUBLIC_SHOPIFY_STORE_DOMAIN!;
const storefrontAccessToken = process.env.NEXT_PUBLIC_SHOPIFY_STOREFRONT_ACCESS_TOKEN!;

// The core function to communicate with Shopify's GraphQL API
async function shopifyFetch<T>({
  query,
  variables,
}: {
  query: string;
  variables?: Record<string, unknown>;
}): Promise<{ status: number; body: T }> {
  try {
    const endpoint = `https://${domain}/api/2024-07/graphql.json`;

    const result = await fetch(endpoint, {
      method: 'POST',
      headers: { 
        'Content-Type': 'application/json', 
        'X-Shopify-Storefront-Access-Token': storefrontAccessToken 
      },
      body: JSON.stringify({ query, variables }),

      // THE FIX: Instead of 'no-store', we use revalidation.
      // This tells Next.js to cache the result but consider it "stale"
      // after 600 seconds (10 minutes). The next visitor after 10 minutes
      // will trigger a fresh data fetch in the background.
      next: { revalidate: 600 }

    });

    const body = await result.json();

    if (body.errors) {
      throw new Error(body.errors[0].message);
    }

    return { status: result.status, body };

  } catch (e) {
    if (e instanceof Error) {
      throw new Error(`Shopify API call failed: ${e.message}`);
    }
    throw new Error('An unknown error occurred during the Shopify API call.');
  }
}


// Fetches a list of products
const getProductsQuery = `
  query getProducts($first: Int!) {
    products(first: $first) {
      edges {
        node {
          id
          handle
          title
          priceRange {
            minVariantPrice {
              amount
              currencyCode
            }
          }
          featuredImage {
            url
            altText
            width
            height
          }
        }
      }
    }
  }
`;
export async function getProducts(count: number): Promise<ShopifyProduct[]> {
  const res = await shopifyFetch<ShopifyProductsResponseBody>({
    query: getProductsQuery,
    variables: { first: count },
  });
  return res.body.data.products.edges.map((edge) => edge.node);
}

// Logs a customer in by creating an access token
const customerLoginMutation = `
  mutation customerAccessTokenCreate($input: CustomerAccessTokenCreateInput!) {
    customerAccessTokenCreate(input: $input) {
      customerUserErrors { code field message }
      customerAccessToken { accessToken expiresAt }
    }
  }
`;
export async function loginCustomer(input: Record<string, unknown>): Promise<CustomerLoginPayload> {
    const res = await shopifyFetch<ShopifyCustomerLoginResponseBody>({
        query: customerLoginMutation,
        variables: { input }
    });
    return res.body.data.customerAccessTokenCreate;
}

// Fetches the full data for an authenticated customer
const getCustomerQuery = `
  query getCustomer($customerAccessToken: String!) {
    customer(customerAccessToken: $customerAccessToken) {
      id
      firstName
      lastName
      email
      addresses(first: 10) {
        edges { node { id address1 address2 city province zip country } }
      }
      orders(first: 20, sortKey: PROCESSED_AT, reverse: true) {
        edges { node { id orderNumber processedAt financialStatus totalPriceV2 { amount currencyCode } } }
      }
    }
  }
`;
export async function getCustomer(customerAccessToken: string): Promise<ShopifyCustomer | null> {
    const res = await shopifyFetch<ShopifyCustomerDataResponseBody>({
        query: getCustomerQuery,
        variables: { customerAccessToken }
    });
    return res.body.data.customer;
}

// Updates a customer's profile details
const customerUpdateMutation = `
  mutation customerUpdate($customerAccessToken: String!, $customer: CustomerUpdateInput!) {
    customerUpdate(customerAccessToken: $customerAccessToken, customer: $customer) {
      customer { id firstName lastName }
      customerUserErrors { code field message }
    }
  }
`;
export async function updateCustomer(token: string, customerData: { firstName: string, lastName: string }): Promise<any> {
    const res = await shopifyFetch<ShopifyCustomerUpdateResponseBody>({
        query: customerUpdateMutation,
        variables: {
            customerAccessToken: token,
            customer: customerData
        }
    });
    return res.body.data.customerUpdate;
}

// Creates a new address for an authenticated customer
const customerAddressCreateMutation = `
  mutation customerAddressCreate($customerAccessToken: String!, $address: MailingAddressInput!) {
    customerAddressCreate(customerAccessToken: $customerAccessToken, address: $address) {
      customerAddress { id }
      customerUserErrors { code field message }
    }
  }
`;
export async function createCustomerAddress(token: string, address: NewAddressInput): Promise<any> {
    const res = await shopifyFetch<ShopifyAddressCreateResponseBody>({
        query: customerAddressCreateMutation,
        variables: {
            customerAccessToken: token,
            address: address
        }
    });
    return res.body.data.customerAddressCreate;
}
// Fetches a single product by its handle
const getProductByHandleQuery = `
  query getProductByHandle($handle: String!) {
    product(handle: $handle) {
      id
      handle
      title
      descriptionHtml
      priceRange {
        minVariantPrice {
          amount
          currencyCode
        }
      }
      featuredImage {
        url
        altText
        width
        height
      }
      images(first: 10) {
        edges {
          node {
            url
            altText
            width
            height
          }
        }
      }
      variants(first: 10) {
        edges {
          node {
            id
            title
            availableForSale
            price {
              amount
              currencyCode
            }
          }
        }
      }
    }
  }
`;


export async function getProductByHandle(handle: string): Promise<ShopifyProductDetailed | null> {
  const res = await shopifyFetch<ShopifyProductDetailedResponseBody>({
    query: getProductByHandleQuery,
    variables: { handle },
  });
  return res.body.data.product;
}


// ADD THIS ENTIRE BLOCK OF CODE TO THE END OF src/lib/shopify.ts

const getProductsDetailedQuery = `
  query getProductsDetailed($first: Int!) {
    products(first: $first) {
      edges {
        node {
          id
          handle
          title
          descriptionHtml
          priceRange {
            minVariantPrice {
              amount
              currencyCode
            }
          }
          featuredImage {
            url
            altText
            width
            height
          }
          images(first: 10) {
            edges {
              node {
                url
                altText
              }
            }
          }
          variants(first: 10) {
            edges {
              node {
                id
                title
                availableForSale
                price {
                  amount
                  currencyCode
                }
              }
            }
          }
        }
      }
    }
  }
`;

export async function getProductsDetailed(count: number): Promise<ShopifyProductDetailed[]> {
  const res = await shopifyFetch<{ data: { products: { edges: { node: ShopifyProductDetailed }[] } } }>({
    query: getProductsDetailedQuery,
    variables: { first: count },
  });
  return res.body.data.products.edges.map((edge) => edge.node);
}

### .\src\middleware.ts ###

// src/middleware.ts

import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

// Define the names of our cookies for clarity
const SITE_ACCESS_TOKEN_NAME = 'swambasic_session';
const CUSTOMER_TOKEN_COOKIE_NAME = 'swambasic_customer_token';

// Define which paths are protected and require a user to be logged in
const PROTECTED_ROUTES = ['/account', '/cart'];

export function middleware(request: NextRequest) {
    const { pathname } = request.nextUrl;

    // --- Protection Mechanism #1: The Main Site Password ---
    // This runs for ALL pages EXCEPT the entry page itself (`/`).
    if (pathname !== '/') {
        const siteAccessToken = request.cookies.get(SITE_ACCESS_TOKEN_NAME);
        
        // If there's no site access token, force the user back to the entry page.
        if (!siteAccessToken) {
            return NextResponse.redirect(new URL('/', request.url));
        }
    }

    // --- Protection Mechanism #2: Customer Login ---
    // This checks if the user is trying to access a route defined in PROTECTED_ROUTES.
    const isProtectedRoute = PROTECTED_ROUTES.some(route => pathname.startsWith(route));

    if (isProtectedRoute) {
        const customerToken = request.cookies.get(CUSTOMER_TOKEN_COOKIE_NAME);

        // If it's a protected route and the user is NOT logged in, redirect to the login page.
        if (!customerToken) {
            return NextResponse.redirect(new URL('/login', request.url));
        }
    }

    // --- Protection Mechanism #3: Prevent Logged-in Users from seeing Login Page ---
    // If a user is already logged in, they shouldn't be able to see the /login page again.
    if (pathname === '/login') {
        const customerToken = request.cookies.get(CUSTOMER_TOKEN_COOKIE_NAME);

        // If they are logged in, redirect them to their account dashboard.
        if (customerToken) {
            return NextResponse.redirect(new URL('/account', request.url));
        }
    }

    // If none of the above rules apply, allow the request to proceed.
    return NextResponse.next();
}

// This config ensures the middleware runs on all paths EXCEPT for static files and API routes.
export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - api (API routes)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     */
    '/((?!api|_next/static|_next/image|favicon.ico).*)',
  ],
}

### .\src\types\global.d.ts ###

import { Object3DNode } from '@react-three/fiber';
import { ShaderMaterial } from 'three';

declare module '@react-three/fiber' {
  interface ThreeElements {
    liquidGradientMaterial: Object3DNode<ShaderMaterial, typeof ShaderMaterial>;
    loginLiquidMaterial: Object3DNode<ShaderMaterial, typeof ShaderMaterial>;
    // ADD THE LINE BELOW
    liquidShaderMaterial: Object3DNode<ShaderMaterial, typeof ShaderMaterial>;

    nebulaMaterial: Object3DNode<ShaderMaterial, typeof ShaderMaterial>;
floatingPointsMaterial: Object3DNode<ShaderMaterial, typeof ShaderMaterial>;
customParticleMaterial: Object3DNode<ShaderMaterial, typeof ShaderMaterial>;
liquidGrainMaterial: Object3DNode<ShaderMaterial, typeof ShaderMaterial>;

    glitchTrailMaterial: Object3DNode<ShaderMaterial, typeof ShaderMaterial>;
    glitchMaterial: Object3DNode<ShaderMaterial, typeof ShaderMaterial>;
    elementalGradientMaterial: Object3DNode<ShaderMaterial, typeof ShaderMaterial>;
atmosphericMaterial: Object3DNode<ShaderMaterial, typeof ShaderMaterial>;


  }
}

### .\src\types\shopify.d.ts ###

// src/types/shopify.d.ts

// Defines the structure of the data we expect back from the Storefront API

interface ShopifyImage {
  url: string;
  altText: string;
  width: number;
  height: number;
}

interface ShopifyPrice {
  amount: string;
  currencyCode: string;
}

export interface ShopifyProduct {
  id: string;
  handle: string;
  title: string;
  priceRange: {
    minVariantPrice: ShopifyPrice;
  };
  featuredImage: ShopifyImage;
}

export interface ShopifyProductsResponseBody {
  data: {
    products: {
      edges: {
        node: ShopifyProduct;
      }[];
    };
  };
}

// === CUSTOMER AUTH TYPES ===

export interface CustomerUserError {
  code: string;
  field: string[];
  message: string;
}

interface CustomerAccessToken {
  accessToken: string;
  expiresAt: string;
}

export interface CustomerCreatePayload {
  customerUserErrors: CustomerUserError[];
  customer?: {
    id: string;
  };
}

export interface CustomerLoginPayload {
    customerUserErrors: CustomerUserError[];
    customerAccessToken?: CustomerAccessToken;
}

export interface ShopifyCustomerCreateResponseBody {
    data: {
        customerCreate: CustomerCreatePayload;
    }
}

export interface ShopifyCustomerLoginResponseBody {
    data: {
        customerAccessTokenCreate: CustomerLoginPayload;
    }
}

// === CUSTOMER DATA TYPES ===

export interface ShopifyOrder {
    id: string;
    orderNumber: number;
    processedAt: string;
    financialStatus: string;
    totalPriceV2: {
        amount: string;
        currencyCode: string;
    };
}

export interface ShopifyAddress {
    id: string;
    address1: string;
    address2: string | null;
    city: string;
    province: string;
    zip: string;
    country: string;
}

export interface ShopifyCustomer {
    id: string;
    firstName: string;
    lastName: string;
    email: string;
    addresses: {
        edges: { node: ShopifyAddress }[];
    };
    orders: {
        edges: { node: ShopifyOrder }[];
    };
}

export interface ShopifyCustomerDataResponseBody {
    data: {
        customer: ShopifyCustomer | null;
    }
}

// === CUSTOMER MANAGEMENT TYPES ===

export interface ShopifyCustomerUpdateResponseBody {
    data: {
        customerUpdate: {
            customer: {
                id: string;
                firstName: string;
                lastName: string;
            };
            customerUserErrors: any[];
        }
    }
}

export interface ShopifyAddressCreateResponseBody {
    data: {
        customerAddressCreate: {
            customerAddress: { id: string } | null;
            customerUserErrors: any[];
        }
    }
}

// This is the input type for creating a new address
export interface NewAddressInput {
    address1: string;
    address2?: string;
    city: string;
    province: string;
    country: string;
    zip: string;
}

export interface ShopifyProductVariant {
  id: string;
  title: string;
  availableForSale: boolean;
  price: ShopifyPrice;
}

export interface ShopifyProductDetailed extends ShopifyProduct {
  descriptionHtml: string;
  images: {
    edges: {
      node: ShopifyImage;
    }[];
  };
  variants: {
    edges: {
      node: ShopifyProductVariant;
    }[];
  };
}

export interface ShopifyProductDetailedResponseBody {
  data: {
    product: ShopifyProductDetailed | null;
  }
}

### .\tailwind.config.ts ###

import type { Config } from 'tailwindcss'
import plugin from 'tailwindcss/plugin'

const config: Config = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  darkMode: 'class',
  theme: {
    extend: {
      colors: {
        'background': '#000000',
        'foreground': '#FFFFFF',
      },
       fontFamily: {
        sans: ['var(--font-poppins)', 'sans-serif'],
        display: ['var(--font-unbounded)', 'sans-serif'], 
        heading: ['var(--font-genoa)', 'sans-serif'],
      },
      // NEW: Add text-shadow theme extension
      textShadow: {
        'glow': '0 0 8px rgba(255, 255, 255, 0.5)',
      },
    },
  },
  // NEW: Add the textShadow plugin
  plugins: [
    plugin(function ({ matchUtilities, theme }) {
      matchUtilities(
        {
          'text-shadow': (value) => ({
            textShadow: value,
          }),
        },
        { values: theme('textShadow') }
      )
    }),
  ],
}
export default config

### .\tsconfig.json ###

{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts", "next.config.mjs"],
  "exclude": ["node_modules"]
}
